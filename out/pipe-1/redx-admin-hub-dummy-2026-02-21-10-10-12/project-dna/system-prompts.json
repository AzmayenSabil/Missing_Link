{
  "generatedAt": "2026-02-21T10:10:55.598Z",
  "model": "gpt-4o-2024-08-06",
  "projectId": "redx-admin-hub-dummy-2026-02-21-10-10-12",
  "prompts": {
    "prd_analysis": {
      "purpose": "PRD Analysis",
      "systemPrompt": "# GitHub Copilot Instructions for RedX Admin Hub\n\n---\n\n## applyTo: '**'\n\nThis file serves as the authoritative guide for AI coding assistants working on the RedX Admin Hub project. It provides comprehensive instructions and conventions that must be followed to ensure consistency and quality across the codebase. AI coding assistants should use this document as the primary reference for understanding the project's architecture, coding standards, and development practices.\n\n## Project Overview\n\nThe RedX Admin Hub is a web-based application designed to manage administrative tasks for the RedX logistics platform. Its primary users are internal staff members, including administrators and finance teams, who require access to parcel tracking, user management, and reporting features. The project is built using React and TypeScript, with a focus on providing a responsive and user-friendly interface. The application leverages Ant Design for UI components and Redux Toolkit for state management, ensuring a scalable and maintainable codebase.\n\n## Architecture & Technology Stack\n\n### Core Technologies\n\n- **React**: A JavaScript library for building user interfaces.\n- **TypeScript**: A typed superset of JavaScript that compiles to plain JavaScript.\n- **Ant Design**: A UI library providing a set of high-quality React components.\n- **Emotion**: A library for writing CSS styles with JavaScript.\n- **Redux Toolkit**: A library for managing application state using Redux.\n- **Axios**: A promise-based HTTP client for making requests to the server.\n\n### Project Structure\n\n```plaintext\n├── .gitignore\n├── bun.lockb\n├── components.json\n├── eslint.config.js\n├── index.html\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── README.md\n├── tailwind.config.ts\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.node.json\n├── vite.config.ts\n├── vitest.config.ts\n├── public\n│   ├── favicon.ico\n│   ├── placeholder.svg\n│   └── robots.txt\n└── src\n    ├── assets\n    │   └── globalStyles.ts\n    ├── components\n    │   ├── authorize\n    │   │   └── Authorize.tsx\n    │   ├── layout\n    │   │   └── AppLayout.tsx\n    │   ├── table\n    │   │   └── TableRenderer.tsx\n    │   └── ui\n    │       ├── accordion.tsx\n    │       ├── alert-dialog.tsx\n    │       ├── alert.tsx\n    │       ├── aspect-ratio.tsx\n    │       ├── avatar.tsx\n    │       ├── badge.tsx\n    │       ├── breadcrumb.tsx\n    │       ├── button.tsx\n    │       ├── calendar.tsx\n    │       ├── card.tsx\n    │       ├── carousel.tsx\n    │       ├── chart.tsx\n    │       ├── checkbox.tsx\n    │       ├── collapsible.tsx\n    │       ├── command.tsx\n    │       ├── context-menu.tsx\n    │       ├── dialog.tsx\n    │       ├── drawer.tsx\n    │       ├── dropdown-menu.tsx\n    │       ├── form.tsx\n    │       ├── hover-card.tsx\n    │       ├── input-otp.tsx\n    │       ├── input.tsx\n    │       ├── label.tsx\n    │       ├── menubar.tsx\n    │       ├── navigation-menu.tsx\n    │       ├── pagination.tsx\n    │       ├── popover.tsx\n    │       ├── progress.tsx\n    │       ├── radio-group.tsx\n    │       ├── resizable.tsx\n    │       ├── scroll-area.tsx\n    │       ├── select.tsx\n    │       ├── separator.tsx\n    │       ├── sheet.tsx\n    │       ├── sidebar.tsx\n    │       ├── skeleton.tsx\n    │       ├── slider.tsx\n    │       ├── sonner.tsx\n    │       ├── switch.tsx\n    │       ├── table.tsx\n    │       ├── tabs.tsx\n    │       ├── textarea.tsx\n    │       ├── toast.tsx\n    │       ├── toaster.tsx\n    │       ├── toggle-group.tsx\n    │       ├── toggle.tsx\n    │       └── tooltip.tsx\n    ├── config\n    │   ├── getPagePermissions.ts\n    │   ├── local.ts\n    │   └── navigation.ts\n    ├── hooks\n    │   ├── use-mobile.tsx\n    │   ├── use-toast.ts\n    │   ├── useAuthorization.ts\n    │   └── useTable.ts\n    ├── pages\n    │   ├── Index.tsx\n    │   ├── Login.tsx\n    │   ├── NotFound.tsx\n    │   └── Parcels.tsx\n    ├── redux\n    │   ├── slices\n    │   │   └── AuthSlice.ts\n    │   └── store.ts\n    ├── services\n    │   ├── authAPI.ts\n    │   ├── axios.config.ts\n    │   └── parcelAPI.ts\n    ├── test\n    │   ├── example.test.ts\n    │   └── setup.ts\n    └── types\n        ├── auth.ts\n        └── parcel.ts\n```\n\n## Code Style & Standards\n\n### Formatting & Linting\n\nThe project does not currently use Prettier or ESLint for code formatting and linting. However, TypeScript is configured with the following settings:\n\n```json\n{\n  \"strict\": false,\n  \"jsx\": null,\n  \"baseUrl\": \".\",\n  \"pathAliases\": {\n    \"@/*\": [\n      \"./src/*\"\n    ]\n  }\n}\n```\n\nFile naming conventions follow camelCase for files and PascalCase for components. There is no commitlint configuration present.\n\n### Import Organization\n\nThe preferred import order is as follows:\n\n1. Framework imports (e.g., React)\n2. UI library imports (e.g., Ant Design)\n3. Third-party library imports\n4. Local hooks\n5. Redux/state imports\n6. Services\n7. Constants\n8. Types\n\nExample:\n\n```typescript\nimport React, { useState } from 'react';\nimport { Button, Input } from 'antd';\nimport axios from 'axios';\nimport { useTable } from '@/hooks/useTable';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel } from '@/types/parcel';\n```\n\n## State Management\n\nThe project uses Redux Toolkit for state management.\n\n### Redux Toolkit Configuration\n\nThe Redux store is configured in `src/redux/store.ts`:\n\n```typescript\nimport { configureStore } from '@reduxjs/toolkit';\nimport { persistStore } from 'redux-persist';\nimport persistedReducer from './reducers';\n\nexport const store = configureStore({\n  reducer: persistedReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n      },\n    }),\n});\n\nexport const persistor = persistStore(store);\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n```\n\n### Redux Slice Example\n\nThe `auth` slice is defined in `src/redux/slices/AuthSlice.ts`:\n\n```typescript\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { AuthState, User } from '@/types/auth';\n\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    setUser(state, action: PayloadAction<User>) {\n      state.user = action.payload;\n      state.isAuthenticated = true;\n    },\n    clearAuth(state) {\n      state.user = null;\n      state.isAuthenticated = false;\n    },\n  },\n});\n\nexport const { setUser, clearAuth } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\n### Typed Hooks\n\nTyped hooks such as `useAppDispatch` and `useAppSelector` are not used in this project. Instead, direct usage of `useDispatch` and `useSelector` is observed.\n\n### Usage Example\n\n```typescript\nimport { useDispatch, useSelector } from 'react-redux';\nimport { RootState } from '@/redux/store';\nimport { setUser } from '@/redux/slices/AuthSlice';\n\nconst Component = () => {\n  const dispatch = useDispatch();\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const handleLogin = (user: User) => {\n    dispatch(setUser(user));\n  };\n\n  return <div>{user ? `Welcome, ${user.name}` : 'Please log in'}</div>;\n};\n```\n\n## Component Patterns\n\n### Page Structure\n\nPages are structured with layout components and authorization guards. For example, the `Parcels` page:\n\n```typescript\n/** @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\nimport { useState, useCallback } from 'react';\nimport { Input, Select, Button, Tag, Space, Modal, Typography, message } from 'antd';\nimport { SearchOutlined, ReloadOutlined } from '@ant-design/icons';\nimport type { ColumnsType } from 'antd/es/table';\nimport Authorize from '@/components/authorize/Authorize';\nimport AppLayout from '@/components/layout/AppLayout';\nimport TableRenderer from '@/components/table/TableRenderer';\nimport { useTable } from '@/hooks/useTable';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel, FetchParcelsParams } from '@/types/parcel';\n\nconst { Title, Text } = Typography;\n\nconst searchBarStyle = css`\n  display: flex;\n  gap: 12px;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n  align-items: flex-end;\n`;\n\nconst Parcels = () => {\n  // Component logic\n};\n\nexport default Parcels;\n```\n\n### Permission-Based Conditional Rendering\n\nComponents like `Authorize` are used to wrap content that requires access control:\n\n```typescript\nimport Authorize from '@/components/authorize/Authorize';\n\nconst ProtectedComponent = () => (\n  <Authorize roles={['Admin', 'User']}>\n    <div>Protected Content</div>\n  </Authorize>\n);\n```\n\n### Primary Form Handling Pattern\n\nForms are handled using Ant Design's `Form` component. Example from `src/pages/Login.tsx`:\n\n```typescript\nimport { Form, Input, Button, message } from 'antd';\n\nconst LoginForm = () => {\n  const [form] = Form.useForm();\n\n  const handleSubmit = async () => {\n    try {\n      const values = await form.validateFields();\n      // Handle login\n    } catch (error) {\n      message.error('Validation failed');\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\">\n      <Form.Item name=\"username\" label=\"Username\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Form.Item name=\"password\" label=\"Password\" rules={[{ required: true }]}>\n        <Input.Password />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSubmit}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n```\n\n### Table/Data-Grid Pattern\n\nTables are rendered using custom hooks and components. Example from `src/components/table/TableRenderer.tsx`:\n\n```typescript\nimport { Table } from 'antd';\nimport { useTable } from '@/hooks/useTable';\nimport { Parcel } from '@/types/parcel';\n\nconst TableRenderer = () => {\n  const { data, loading, onPaginationChange } = useTable<Parcel, FetchParcelsParams>({\n    initialParams: { limit: 10, offset: 0 },\n    fetchFn: fetchParcels,\n  });\n\n  return (\n    <Table\n      dataSource={data}\n      loading={loading}\n      pagination={{ onChange: onPaginationChange }}\n      // Define columns\n    />\n  );\n};\n```\n\n### Styling Approach\n\nThe project uses Emotion for styling components. Example from `src/assets/globalStyles.ts`:\n\n```typescript\nimport { css } from '@emotion/react';\n\nexport const globalStyles = css`\n  body {\n    margin: 0;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: #f5f5f5;\n  }\n\n  #root {\n    min-height: 100vh;\n  }\n`;\n```\n\n## API Integration\n\n### HTTP Client Configuration\n\nThe project uses Axios for HTTP requests. The Axios instance is configured in `src/services/axios.config.ts`:\n\n```typescript\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n  baseURL: 'https://dummy-api.redx.local',\n  timeout: 5000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nexport default apiClient;\n```\n\n### Service Layer Pattern\n\nService modules encapsulate API calls. Example from `src/services/parcelAPI.ts`:\n\n```typescript\nimport apiClient from './axios.config';\nimport { FetchParcelsParams, FetchParcelsResponse } from '@/types/parcel';\n\nexport const fetchParcels = async (params: FetchParcelsParams): Promise<FetchParcelsResponse> => {\n  const response = await apiClient.get('/parcels', { params });\n  return response.data;\n};\n```\n\n### Error Handling\n\nError handling is typically done using try/catch blocks with user feedback via Ant Design's `message` component:\n\n```typescript\nimport { message } from 'antd';\n\nconst fetchData = async () => {\n  try {\n    const response = await apiClient.get('/data');\n    // Handle response\n  } catch (error) {\n    message.error('Failed to fetch data');\n  }\n};\n```\n\n## Navigation & Routing\n\nThe project uses React Router for navigation. The routing configuration is defined in `src/App.tsx`:\n\n```typescript\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport Login from '@/pages/Login';\nimport Parcels from '@/pages/Parcels';\nimport NotFound from '@/pages/NotFound';\n\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<Navigate to=\"/parcels\" replace />} />\n      <Route path=\"/login\" element={<Login />} />\n      <Route path=\"/parcels\" element={<Parcels />} />\n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  </BrowserRouter>\n);\n\nexport default App;\n```\n\n### Menu/Navigation Configuration\n\nNavigation items are defined in `src/config/navigation.ts`:\n\n```typescript\nexport interface NavItem {\n  key: string;\n  label: string;\n  path: string;\n  roles: string[];\n}\n\nexport const navigationItems: NavItem[] = [\n  {\n    key: 'parcels',\n    label: 'Parcels',\n    path: '/parcels',\n    roles: ['RedX Super Admin', 'RedX Finance Team'],\n  },\n];\n```\n\n## Authentication & Authorization\n\n### Authentication Flow\n\nThe authentication flow involves sending an OTP to the user's phone and verifying it. Example from `src/pages/Login.tsx`:\n\n```typescript\nimport { useState } from 'react';\nimport { Form, Input, Button, message } from 'antd';\nimport { useDispatch } from 'react-redux';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { requestLoginOtp, verifyOtp } from '@/services/authAPI';\n\nconst Login = () => {\n  const [loading, setLoading] = useState(false);\n  const [otpSent, setOtpSent] = useState(false);\n  const [form] = Form.useForm();\n  const dispatch = useDispatch();\n\n  const handleSendOtp = async () => {\n    try {\n      const phone = form.getFieldValue('phone');\n      if (!phone) {\n        message.error('Please enter phone number');\n        return;\n      }\n      setLoading(true);\n      await requestLoginOtp({ phone });\n      message.success('OTP sent successfully!');\n      setOtpSent(true);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleLogin = async () => {\n    try {\n      const values = await form.validateFields();\n      setLoading(true);\n      const res = await verifyOtp({\n        phone: values.phone,\n        otp: values.otp,\n      });\n      if (res.success && res.user) {\n        dispatch(setUser(res.user));\n        message.success('Login successful!');\n      } else {\n        message.error(res.error || 'Login failed');\n      }\n    } catch {\n      // validation error\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\">\n      <Form.Item name=\"phone\" label=\"Phone Number\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Form.Item name=\"otp\" label=\"OTP\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSendOtp} loading={loading}>\n        Send OTP\n      </Button>\n      <Button type=\"primary\" onClick={handleLogin} loading={loading} disabled={!otpSent}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n\nexport default Login;\n```\n\n### Authorization Patterns\n\nAuthorization is handled using hooks and components. Example from `src/hooks/useAuthorization.ts`:\n\n```typescript\nimport { useSelector } from 'react-redux';\nimport { RootState } from '@/redux/store';\n\nexport const useAuthorization = ({ roles }: { roles: string[] }) => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) => userRoleNames.includes(role));\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n## Common Utilities\n\n### Utility Modules\n\n- **Form Helpers** (`src/lib/formHelpers.ts`)\n\n  ```typescript\n  export const handleNumericValueChange = (value: string): string => {\n    return value.replace(/[^0-9]/g, '');\n  };\n\n  export const disableFutureDates = (current: Dayjs): boolean => {\n    return current && current.valueOf() > Date.now();\n  };\n  ```\n\n- **Utils** (`src/lib/utils.ts`)\n\n  ```typescript\n  import { twMerge } from 'tailwind-merge';\n  import clsx from 'clsx';\n\n  export function cn(...inputs: ClassValue[]) {\n    return twMerge(clsx(inputs));\n  }\n  ```\n\n## Testing & Quality\n\n### Testing Framework\n\nThe project uses Vitest for testing. The configuration is defined in `vitest.config.ts`:\n\n```typescript\nimport { defineConfig } from 'vitest/config';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: ['./src/test/setup.ts'],\n    include: ['src/**/*.{test,spec}.{ts,tsx}'],\n  },\n  resolve: {\n    alias: { '@': path.resolve(__dirname, './src') },\n  },\n});\n```\n\n### Test-ID Conventions\n\nTest IDs are used in form inputs for testing purposes:\n\n```typescript\n<Form.Item name=\"phone\" label=\"Phone Number\" rules={[{ required: true }]}>\n  <Input data-testid=\"phone-input\" />\n</Form.Item>\n```\n\n### Lint/Test/Type-Check Commands\n\nThe project does not have specific linting or type-checking commands configured. Testing can be run using Vitest:\n\n```bash\nvitest run\n```\n\n## Environment Variables\n\nThe project does not specify any required environment variables in the DNA snapshot.\n\n## Development Workflow\n\n### Local Development\n\nTo set up the project locally, use the following commands:\n\n```bash\n# Install dependencies\nnpm install\n\n# Start the development server\nnpm run dev\n\n# Build the project\nnpm run build\n\n# Start the production server\nnpm start\n```\n\n### Local Setup Requirements\n\n- Node.js version: 16.x or higher\n- Package manager: npm\n- External services: None specified\n\n### Git Workflow\n\nThe project does not specify a conventional commits format or branch naming convention. There is no CI/CD pipeline evident in the DNA snapshot.\n\n## Performance Considerations\n\n### Code Splitting\n\nThe project does not specify a code splitting strategy in the DNA snapshot.\n\n### Lazy Loading\n\nLazy loading is not explicitly mentioned in the DNA snapshot.\n\n### Tree Shaking\n\nTree shaking is not explicitly mentioned in the DNA snapshot.\n\n### Bundle Analysis Tools\n\nBundle analysis tools are not explicitly mentioned in the DNA snapshot.\n\n## Common Patterns to Follow\n\n1. Use Emotion for styling components.\n2. Wrap route content with `Authorize` where access control is required.\n3. Prefer Ant Design components for consistent UI patterns.\n4. Use `useTable` hook for table data management.\n5. Use `apiClient` for all HTTP requests.\n6. Define navigation items in `src/config/navigation.ts`.\n7. Use `useAuthorization` hook for role-based access control.\n8. Handle form submissions using Ant Design's `Form` component.\n9. Use `message` component from Ant Design for user feedback.\n10. Define Redux slices using `createSlice` from Redux Toolkit.\n11. Use `persistStore` for Redux state persistence.\n12. Use `useDispatch` and `useSelector` for Redux state management.\n\n## Domain-Specific Features\n\n### Parcel Management\n\n- **Purpose**: Manage parcel tracking and status updates.\n- **Key Components**: `Parcels` page, `TableRenderer` component, `useTable` hook.\n- **Special Patterns**: Use of `useTable` hook for pagination and data fetching.\n\n## Debugging & Development Tools\n\n### DevTools Integration\n\n- **Redux DevTools**: Not explicitly mentioned, but can be integrated for state debugging.\n- **React DevTools**: Can be used for component inspection.\n\n### Logging Patterns\n\nLogging is done using `console.error` for error tracking, as seen in `src/pages/NotFound.tsx`.\n\n### Source Maps\n\nSource maps are not explicitly mentioned in the DNA snapshot.\n\n## Migration Notes\n\nNo ongoing migrations are detected in the DNA snapshot.\n\n## Best Practices\n\n1. Use design tokens for consistent theming.\n2. Avoid using hex colors directly; use design tokens instead.\n3. Ensure all pages are wrapped with `Authorize` where necessary.\n4. Use Ant Design components for form handling.\n5. Keep API service logic encapsulated in service modules.\n6. Use `useCallback` and `useEffect` hooks for performance optimization.\n7. Ensure all components are styled using Emotion.\n8. Use TypeScript interfaces for type safety.\n9. Maintain a consistent import order across files.\n10. Use `message` component for consistent user feedback.\n\nRemember: The RedX Admin Hub is designed to streamline administrative tasks for the RedX logistics platform, ensuring efficient parcel management and user access control."
    },
    "architecture_planning": {
      "purpose": "Architecture Planning",
      "systemPrompt": "# GitHub Copilot Instructions for RedX Admin Hub\n\n---\n\n## applyTo: '**'\n\nThis file serves as the authoritative guide for AI coding assistants working on the RedX Admin Hub project. It provides comprehensive instructions and conventions that must be followed to ensure consistency and quality across the codebase. AI coding assistants should use this document as the primary reference for understanding the project's architecture, coding standards, and development practices.\n\n## Project Overview\n\nThe RedX Admin Hub is a web-based application designed to manage administrative tasks for the RedX logistics platform. Its primary users are internal staff members, including administrators and finance teams, who require access to parcel tracking, user management, and reporting features. The project is built using React and TypeScript, with a focus on providing a responsive and user-friendly interface. The application leverages Ant Design for UI components and Redux Toolkit for state management, ensuring a scalable and maintainable codebase.\n\n## Architecture & Technology Stack\n\n### Core Technologies\n\n- **React**: A JavaScript library for building user interfaces.\n- **TypeScript**: A typed superset of JavaScript that compiles to plain JavaScript.\n- **Ant Design**: A UI library providing a set of high-quality React components.\n- **Emotion**: A library for writing CSS styles with JavaScript.\n- **Redux Toolkit**: A library for managing application state using Redux.\n- **Axios**: A promise-based HTTP client for making requests to the server.\n\n### Project Structure\n\n```plaintext\n├── .gitignore\n├── bun.lockb\n├── components.json\n├── eslint.config.js\n├── index.html\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── README.md\n├── tailwind.config.ts\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.node.json\n├── vite.config.ts\n├── vitest.config.ts\n├── public\n│   ├── favicon.ico\n│   ├── placeholder.svg\n│   └── robots.txt\n└── src\n    ├── assets\n    │   └── globalStyles.ts\n    ├── components\n    │   ├── authorize\n    │   │   └── Authorize.tsx\n    │   ├── layout\n    │   │   └── AppLayout.tsx\n    │   ├── table\n    │   │   └── TableRenderer.tsx\n    │   └── ui\n    │       ├── accordion.tsx\n    │       ├── alert-dialog.tsx\n    │       ├── alert.tsx\n    │       ├── aspect-ratio.tsx\n    │       ├── avatar.tsx\n    │       ├── badge.tsx\n    │       ├── breadcrumb.tsx\n    │       ├── button.tsx\n    │       ├── calendar.tsx\n    │       ├── card.tsx\n    │       ├── carousel.tsx\n    │       ├── chart.tsx\n    │       ├── checkbox.tsx\n    │       ├── collapsible.tsx\n    │       ├── command.tsx\n    │       ├── context-menu.tsx\n    │       ├── dialog.tsx\n    │       ├── drawer.tsx\n    │       ├── dropdown-menu.tsx\n    │       ├── form.tsx\n    │       ├── hover-card.tsx\n    │       ├── input-otp.tsx\n    │       ├── input.tsx\n    │       ├── label.tsx\n    │       ├── menubar.tsx\n    │       ├── navigation-menu.tsx\n    │       ├── pagination.tsx\n    │       ├── popover.tsx\n    │       ├── progress.tsx\n    │       ├── radio-group.tsx\n    │       ├── resizable.tsx\n    │       ├── scroll-area.tsx\n    │       ├── select.tsx\n    │       ├── separator.tsx\n    │       ├── sheet.tsx\n    │       ├── sidebar.tsx\n    │       ├── skeleton.tsx\n    │       ├── slider.tsx\n    │       ├── sonner.tsx\n    │       ├── switch.tsx\n    │       ├── table.tsx\n    │       ├── tabs.tsx\n    │       ├── textarea.tsx\n    │       ├── toast.tsx\n    │       ├── toaster.tsx\n    │       ├── toggle-group.tsx\n    │       ├── toggle.tsx\n    │       └── tooltip.tsx\n    ├── config\n    │   ├── getPagePermissions.ts\n    │   ├── local.ts\n    │   └── navigation.ts\n    ├── hooks\n    │   ├── use-mobile.tsx\n    │   ├── use-toast.ts\n    │   ├── useAuthorization.ts\n    │   └── useTable.ts\n    ├── pages\n    │   ├── Index.tsx\n    │   ├── Login.tsx\n    │   ├── NotFound.tsx\n    │   └── Parcels.tsx\n    ├── redux\n    │   ├── slices\n    │   │   └── AuthSlice.ts\n    │   └── store.ts\n    ├── services\n    │   ├── authAPI.ts\n    │   ├── axios.config.ts\n    │   └── parcelAPI.ts\n    ├── test\n    │   ├── example.test.ts\n    │   └── setup.ts\n    └── types\n        ├── auth.ts\n        └── parcel.ts\n```\n\n## Code Style & Standards\n\n### Formatting & Linting\n\nThe project does not currently use Prettier or ESLint for code formatting and linting. However, TypeScript is configured with the following settings:\n\n```json\n{\n  \"strict\": false,\n  \"jsx\": null,\n  \"baseUrl\": \".\",\n  \"pathAliases\": {\n    \"@/*\": [\n      \"./src/*\"\n    ]\n  }\n}\n```\n\nFile naming conventions follow camelCase for files and PascalCase for components. There is no commitlint configuration present.\n\n### Import Organization\n\nThe preferred import order is as follows:\n\n1. Framework imports (e.g., React)\n2. UI library imports (e.g., Ant Design)\n3. Third-party library imports\n4. Local hooks\n5. Redux/state imports\n6. Services\n7. Constants\n8. Types\n\nExample:\n\n```typescript\nimport React, { useState } from 'react';\nimport { Button, Input } from 'antd';\nimport axios from 'axios';\nimport { useTable } from '@/hooks/useTable';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel } from '@/types/parcel';\n```\n\n## State Management\n\nThe project uses Redux Toolkit for state management.\n\n### Redux Toolkit Configuration\n\nThe Redux store is configured in `src/redux/store.ts`:\n\n```typescript\nimport { configureStore } from '@reduxjs/toolkit';\nimport { persistStore } from 'redux-persist';\nimport persistedReducer from './reducers';\n\nexport const store = configureStore({\n  reducer: persistedReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n      },\n    }),\n});\n\nexport const persistor = persistStore(store);\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n```\n\n### Redux Slice Example\n\nThe `auth` slice is defined in `src/redux/slices/AuthSlice.ts`:\n\n```typescript\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { AuthState, User } from '@/types/auth';\n\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    setUser(state, action: PayloadAction<User>) {\n      state.user = action.payload;\n      state.isAuthenticated = true;\n    },\n    clearAuth(state) {\n      state.user = null;\n      state.isAuthenticated = false;\n    },\n  },\n});\n\nexport const { setUser, clearAuth } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\n### Typed Hooks\n\nTyped hooks such as `useAppDispatch` and `useAppSelector` are not used in this project. Instead, direct usage of `useDispatch` and `useSelector` is observed.\n\n### Usage Example\n\n```typescript\nimport { useDispatch, useSelector } from 'react-redux';\nimport { RootState } from '@/redux/store';\nimport { setUser } from '@/redux/slices/AuthSlice';\n\nconst Component = () => {\n  const dispatch = useDispatch();\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const handleLogin = (user: User) => {\n    dispatch(setUser(user));\n  };\n\n  return <div>{user ? `Welcome, ${user.name}` : 'Please log in'}</div>;\n};\n```\n\n## Component Patterns\n\n### Page Structure\n\nPages are structured with layout components and authorization guards. For example, the `Parcels` page:\n\n```typescript\n/** @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\nimport { useState, useCallback } from 'react';\nimport { Input, Select, Button, Tag, Space, Modal, Typography, message } from 'antd';\nimport { SearchOutlined, ReloadOutlined } from '@ant-design/icons';\nimport type { ColumnsType } from 'antd/es/table';\nimport Authorize from '@/components/authorize/Authorize';\nimport AppLayout from '@/components/layout/AppLayout';\nimport TableRenderer from '@/components/table/TableRenderer';\nimport { useTable } from '@/hooks/useTable';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel, FetchParcelsParams } from '@/types/parcel';\n\nconst { Title, Text } = Typography;\n\nconst searchBarStyle = css`\n  display: flex;\n  gap: 12px;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n  align-items: flex-end;\n`;\n\nconst Parcels = () => {\n  // Component logic\n};\n\nexport default Parcels;\n```\n\n### Permission-Based Conditional Rendering\n\nComponents like `Authorize` are used to wrap content that requires access control:\n\n```typescript\nimport Authorize from '@/components/authorize/Authorize';\n\nconst ProtectedComponent = () => (\n  <Authorize roles={['Admin', 'User']}>\n    <div>Protected Content</div>\n  </Authorize>\n);\n```\n\n### Primary Form Handling Pattern\n\nForms are handled using Ant Design's `Form` component. Example from `src/pages/Login.tsx`:\n\n```typescript\nimport { Form, Input, Button, message } from 'antd';\n\nconst LoginForm = () => {\n  const [form] = Form.useForm();\n\n  const handleSubmit = async () => {\n    try {\n      const values = await form.validateFields();\n      // Handle login\n    } catch (error) {\n      message.error('Validation failed');\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\">\n      <Form.Item name=\"username\" label=\"Username\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Form.Item name=\"password\" label=\"Password\" rules={[{ required: true }]}>\n        <Input.Password />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSubmit}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n```\n\n### Table/Data-Grid Pattern\n\nTables are rendered using custom hooks and components. Example from `src/components/table/TableRenderer.tsx`:\n\n```typescript\nimport { Table } from 'antd';\nimport { useTable } from '@/hooks/useTable';\nimport { Parcel } from '@/types/parcel';\n\nconst TableRenderer = () => {\n  const { data, loading, onPaginationChange } = useTable<Parcel, FetchParcelsParams>({\n    initialParams: { limit: 10, offset: 0 },\n    fetchFn: fetchParcels,\n  });\n\n  return (\n    <Table\n      dataSource={data}\n      loading={loading}\n      pagination={{ onChange: onPaginationChange }}\n      // Define columns\n    />\n  );\n};\n```\n\n### Styling Approach\n\nThe project uses Emotion for styling components. Example from `src/assets/globalStyles.ts`:\n\n```typescript\nimport { css } from '@emotion/react';\n\nexport const globalStyles = css`\n  body {\n    margin: 0;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: #f5f5f5;\n  }\n\n  #root {\n    min-height: 100vh;\n  }\n`;\n```\n\n## API Integration\n\n### HTTP Client Configuration\n\nThe project uses Axios for HTTP requests. The Axios instance is configured in `src/services/axios.config.ts`:\n\n```typescript\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n  baseURL: 'https://dummy-api.redx.local',\n  timeout: 5000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nexport default apiClient;\n```\n\n### Service Layer Pattern\n\nService modules encapsulate API calls. Example from `src/services/parcelAPI.ts`:\n\n```typescript\nimport apiClient from './axios.config';\nimport { FetchParcelsParams, FetchParcelsResponse } from '@/types/parcel';\n\nexport const fetchParcels = async (params: FetchParcelsParams): Promise<FetchParcelsResponse> => {\n  const response = await apiClient.get('/parcels', { params });\n  return response.data;\n};\n```\n\n### Error Handling\n\nError handling is typically done using try/catch blocks with user feedback via Ant Design's `message` component:\n\n```typescript\nimport { message } from 'antd';\n\nconst fetchData = async () => {\n  try {\n    const response = await apiClient.get('/data');\n    // Handle response\n  } catch (error) {\n    message.error('Failed to fetch data');\n  }\n};\n```\n\n## Navigation & Routing\n\nThe project uses React Router for navigation. The routing configuration is defined in `src/App.tsx`:\n\n```typescript\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport Login from '@/pages/Login';\nimport Parcels from '@/pages/Parcels';\nimport NotFound from '@/pages/NotFound';\n\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<Navigate to=\"/parcels\" replace />} />\n      <Route path=\"/login\" element={<Login />} />\n      <Route path=\"/parcels\" element={<Parcels />} />\n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  </BrowserRouter>\n);\n\nexport default App;\n```\n\n### Menu/Navigation Configuration\n\nNavigation items are defined in `src/config/navigation.ts`:\n\n```typescript\nexport interface NavItem {\n  key: string;\n  label: string;\n  path: string;\n  roles: string[];\n}\n\nexport const navigationItems: NavItem[] = [\n  {\n    key: 'parcels',\n    label: 'Parcels',\n    path: '/parcels',\n    roles: ['RedX Super Admin', 'RedX Finance Team'],\n  },\n];\n```\n\n## Authentication & Authorization\n\n### Authentication Flow\n\nThe authentication flow involves sending an OTP to the user's phone and verifying it. Example from `src/pages/Login.tsx`:\n\n```typescript\nimport { useState } from 'react';\nimport { Form, Input, Button, message } from 'antd';\nimport { useDispatch } from 'react-redux';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { requestLoginOtp, verifyOtp } from '@/services/authAPI';\n\nconst Login = () => {\n  const [loading, setLoading] = useState(false);\n  const [otpSent, setOtpSent] = useState(false);\n  const [form] = Form.useForm();\n  const dispatch = useDispatch();\n\n  const handleSendOtp = async () => {\n    try {\n      const phone = form.getFieldValue('phone');\n      if (!phone) {\n        message.error('Please enter phone number');\n        return;\n      }\n      setLoading(true);\n      await requestLoginOtp({ phone });\n      message.success('OTP sent successfully!');\n      setOtpSent(true);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleLogin = async () => {\n    try {\n      const values = await form.validateFields();\n      setLoading(true);\n      const res = await verifyOtp({\n        phone: values.phone,\n        otp: values.otp,\n      });\n      if (res.success && res.user) {\n        dispatch(setUser(res.user));\n        message.success('Login successful!');\n      } else {\n        message.error(res.error || 'Login failed');\n      }\n    } catch {\n      // validation error\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\">\n      <Form.Item name=\"phone\" label=\"Phone Number\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Form.Item name=\"otp\" label=\"OTP\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSendOtp} loading={loading}>\n        Send OTP\n      </Button>\n      <Button type=\"primary\" onClick={handleLogin} loading={loading} disabled={!otpSent}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n\nexport default Login;\n```\n\n### Authorization Patterns\n\nAuthorization is handled using hooks and components. Example from `src/hooks/useAuthorization.ts`:\n\n```typescript\nimport { useSelector } from 'react-redux';\nimport { RootState } from '@/redux/store';\n\nexport const useAuthorization = ({ roles }: { roles: string[] }) => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) => userRoleNames.includes(role));\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n## Common Utilities\n\n### Utility Modules\n\n- **Form Helpers** (`src/lib/formHelpers.ts`)\n\n  ```typescript\n  export const handleNumericValueChange = (value: string): string => {\n    return value.replace(/[^0-9]/g, '');\n  };\n\n  export const disableFutureDates = (current: Dayjs): boolean => {\n    return current && current.valueOf() > Date.now();\n  };\n  ```\n\n- **Utils** (`src/lib/utils.ts`)\n\n  ```typescript\n  import { twMerge } from 'tailwind-merge';\n  import clsx from 'clsx';\n\n  export function cn(...inputs: ClassValue[]) {\n    return twMerge(clsx(inputs));\n  }\n  ```\n\n## Testing & Quality\n\n### Testing Framework\n\nThe project uses Vitest for testing. The configuration is defined in `vitest.config.ts`:\n\n```typescript\nimport { defineConfig } from 'vitest/config';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: ['./src/test/setup.ts'],\n    include: ['src/**/*.{test,spec}.{ts,tsx}'],\n  },\n  resolve: {\n    alias: { '@': path.resolve(__dirname, './src') },\n  },\n});\n```\n\n### Test-ID Conventions\n\nTest IDs are used in form inputs for testing purposes:\n\n```typescript\n<Form.Item name=\"phone\" label=\"Phone Number\" rules={[{ required: true }]}>\n  <Input data-testid=\"phone-input\" />\n</Form.Item>\n```\n\n### Lint/Test/Type-Check Commands\n\nThe project does not have specific linting or type-checking commands configured. Testing can be run using Vitest:\n\n```bash\nvitest run\n```\n\n## Environment Variables\n\nThe project does not specify any required environment variables in the DNA snapshot.\n\n## Development Workflow\n\n### Local Development\n\nTo set up the project locally, use the following commands:\n\n```bash\n# Install dependencies\nnpm install\n\n# Start the development server\nnpm run dev\n\n# Build the project\nnpm run build\n\n# Start the production server\nnpm start\n```\n\n### Local Setup Requirements\n\n- Node.js version: 16.x or higher\n- Package manager: npm\n- External services: None specified\n\n### Git Workflow\n\nThe project does not specify a conventional commits format or branch naming convention. There is no CI/CD pipeline evident in the DNA snapshot.\n\n## Performance Considerations\n\n### Code Splitting\n\nThe project does not specify a code splitting strategy in the DNA snapshot.\n\n### Lazy Loading\n\nLazy loading is not explicitly mentioned in the DNA snapshot.\n\n### Tree Shaking\n\nTree shaking is not explicitly mentioned in the DNA snapshot.\n\n### Bundle Analysis Tools\n\nBundle analysis tools are not explicitly mentioned in the DNA snapshot.\n\n## Common Patterns to Follow\n\n1. Use Emotion for styling components.\n2. Wrap route content with `Authorize` where access control is required.\n3. Prefer Ant Design components for consistent UI patterns.\n4. Use `useTable` hook for table data management.\n5. Use `apiClient` for all HTTP requests.\n6. Define navigation items in `src/config/navigation.ts`.\n7. Use `useAuthorization` hook for role-based access control.\n8. Handle form submissions using Ant Design's `Form` component.\n9. Use `message` component from Ant Design for user feedback.\n10. Define Redux slices using `createSlice` from Redux Toolkit.\n11. Use `persistStore` for Redux state persistence.\n12. Use `useDispatch` and `useSelector` for Redux state management.\n\n## Domain-Specific Features\n\n### Parcel Management\n\n- **Purpose**: Manage parcel tracking and status updates.\n- **Key Components**: `Parcels` page, `TableRenderer` component, `useTable` hook.\n- **Special Patterns**: Use of `useTable` hook for pagination and data fetching.\n\n## Debugging & Development Tools\n\n### DevTools Integration\n\n- **Redux DevTools**: Not explicitly mentioned, but can be integrated for state debugging.\n- **React DevTools**: Can be used for component inspection.\n\n### Logging Patterns\n\nLogging is done using `console.error` for error tracking, as seen in `src/pages/NotFound.tsx`.\n\n### Source Maps\n\nSource maps are not explicitly mentioned in the DNA snapshot.\n\n## Migration Notes\n\nNo ongoing migrations are detected in the DNA snapshot.\n\n## Best Practices\n\n1. Use design tokens for consistent theming.\n2. Avoid using hex colors directly; use design tokens instead.\n3. Ensure all pages are wrapped with `Authorize` where necessary.\n4. Use Ant Design components for form handling.\n5. Keep API service logic encapsulated in service modules.\n6. Use `useCallback` and `useEffect` hooks for performance optimization.\n7. Ensure all components are styled using Emotion.\n8. Use TypeScript interfaces for type safety.\n9. Maintain a consistent import order across files.\n10. Use `message` component for consistent user feedback.\n\nRemember: The RedX Admin Hub is designed to streamline administrative tasks for the RedX logistics platform, ensuring efficient parcel management and user access control."
    },
    "code_generation": {
      "purpose": "Code Generation",
      "systemPrompt": "# GitHub Copilot Instructions for RedX Admin Hub\n\n---\n\n## applyTo: '**'\n\nThis file serves as the authoritative guide for AI coding assistants working on the RedX Admin Hub project. It provides comprehensive instructions and conventions that must be followed to ensure consistency and quality across the codebase. AI coding assistants should use this document as the primary reference for understanding the project's architecture, coding standards, and development practices.\n\n## Project Overview\n\nThe RedX Admin Hub is a web-based application designed to manage administrative tasks for the RedX logistics platform. Its primary users are internal staff members, including administrators and finance teams, who require access to parcel tracking, user management, and reporting features. The project is built using React and TypeScript, with a focus on providing a responsive and user-friendly interface. The application leverages Ant Design for UI components and Redux Toolkit for state management, ensuring a scalable and maintainable codebase.\n\n## Architecture & Technology Stack\n\n### Core Technologies\n\n- **React**: A JavaScript library for building user interfaces.\n- **TypeScript**: A typed superset of JavaScript that compiles to plain JavaScript.\n- **Ant Design**: A UI library providing a set of high-quality React components.\n- **Emotion**: A library for writing CSS styles with JavaScript.\n- **Redux Toolkit**: A library for managing application state using Redux.\n- **Axios**: A promise-based HTTP client for making requests to the server.\n\n### Project Structure\n\n```plaintext\n├── .gitignore\n├── bun.lockb\n├── components.json\n├── eslint.config.js\n├── index.html\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── README.md\n├── tailwind.config.ts\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.node.json\n├── vite.config.ts\n├── vitest.config.ts\n├── public\n│   ├── favicon.ico\n│   ├── placeholder.svg\n│   └── robots.txt\n└── src\n    ├── assets\n    │   └── globalStyles.ts\n    ├── components\n    │   ├── authorize\n    │   │   └── Authorize.tsx\n    │   ├── layout\n    │   │   └── AppLayout.tsx\n    │   ├── table\n    │   │   └── TableRenderer.tsx\n    │   └── ui\n    │       ├── accordion.tsx\n    │       ├── alert-dialog.tsx\n    │       ├── alert.tsx\n    │       ├── aspect-ratio.tsx\n    │       ├── avatar.tsx\n    │       ├── badge.tsx\n    │       ├── breadcrumb.tsx\n    │       ├── button.tsx\n    │       ├── calendar.tsx\n    │       ├── card.tsx\n    │       ├── carousel.tsx\n    │       ├── chart.tsx\n    │       ├── checkbox.tsx\n    │       ├── collapsible.tsx\n    │       ├── command.tsx\n    │       ├── context-menu.tsx\n    │       ├── dialog.tsx\n    │       ├── drawer.tsx\n    │       ├── dropdown-menu.tsx\n    │       ├── form.tsx\n    │       ├── hover-card.tsx\n    │       ├── input-otp.tsx\n    │       ├── input.tsx\n    │       ├── label.tsx\n    │       ├── menubar.tsx\n    │       ├── navigation-menu.tsx\n    │       ├── pagination.tsx\n    │       ├── popover.tsx\n    │       ├── progress.tsx\n    │       ├── radio-group.tsx\n    │       ├── resizable.tsx\n    │       ├── scroll-area.tsx\n    │       ├── select.tsx\n    │       ├── separator.tsx\n    │       ├── sheet.tsx\n    │       ├── sidebar.tsx\n    │       ├── skeleton.tsx\n    │       ├── slider.tsx\n    │       ├── sonner.tsx\n    │       ├── switch.tsx\n    │       ├── table.tsx\n    │       ├── tabs.tsx\n    │       ├── textarea.tsx\n    │       ├── toast.tsx\n    │       ├── toaster.tsx\n    │       ├── toggle-group.tsx\n    │       ├── toggle.tsx\n    │       └── tooltip.tsx\n    ├── config\n    │   ├── getPagePermissions.ts\n    │   ├── local.ts\n    │   └── navigation.ts\n    ├── hooks\n    │   ├── use-mobile.tsx\n    │   ├── use-toast.ts\n    │   ├── useAuthorization.ts\n    │   └── useTable.ts\n    ├── pages\n    │   ├── Index.tsx\n    │   ├── Login.tsx\n    │   ├── NotFound.tsx\n    │   └── Parcels.tsx\n    ├── redux\n    │   ├── slices\n    │   │   └── AuthSlice.ts\n    │   └── store.ts\n    ├── services\n    │   ├── authAPI.ts\n    │   ├── axios.config.ts\n    │   └── parcelAPI.ts\n    ├── test\n    │   ├── example.test.ts\n    │   └── setup.ts\n    └── types\n        ├── auth.ts\n        └── parcel.ts\n```\n\n## Code Style & Standards\n\n### Formatting & Linting\n\nThe project does not currently use Prettier or ESLint for code formatting and linting. However, TypeScript is configured with the following settings:\n\n```json\n{\n  \"strict\": false,\n  \"jsx\": null,\n  \"baseUrl\": \".\",\n  \"pathAliases\": {\n    \"@/*\": [\n      \"./src/*\"\n    ]\n  }\n}\n```\n\nFile naming conventions follow camelCase for files and PascalCase for components. There is no commitlint configuration present.\n\n### Import Organization\n\nThe preferred import order is as follows:\n\n1. Framework imports (e.g., React)\n2. UI library imports (e.g., Ant Design)\n3. Third-party library imports\n4. Local hooks\n5. Redux/state imports\n6. Services\n7. Constants\n8. Types\n\nExample:\n\n```typescript\nimport React, { useState } from 'react';\nimport { Button, Input } from 'antd';\nimport axios from 'axios';\nimport { useTable } from '@/hooks/useTable';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel } from '@/types/parcel';\n```\n\n## State Management\n\nThe project uses Redux Toolkit for state management.\n\n### Redux Toolkit Configuration\n\nThe Redux store is configured in `src/redux/store.ts`:\n\n```typescript\nimport { configureStore } from '@reduxjs/toolkit';\nimport { persistStore } from 'redux-persist';\nimport persistedReducer from './reducers';\n\nexport const store = configureStore({\n  reducer: persistedReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n      },\n    }),\n});\n\nexport const persistor = persistStore(store);\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n```\n\n### Redux Slice Example\n\nThe `auth` slice is defined in `src/redux/slices/AuthSlice.ts`:\n\n```typescript\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { AuthState, User } from '@/types/auth';\n\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    setUser(state, action: PayloadAction<User>) {\n      state.user = action.payload;\n      state.isAuthenticated = true;\n    },\n    clearAuth(state) {\n      state.user = null;\n      state.isAuthenticated = false;\n    },\n  },\n});\n\nexport const { setUser, clearAuth } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\n### Typed Hooks\n\nTyped hooks such as `useAppDispatch` and `useAppSelector` are not used in this project. Instead, direct usage of `useDispatch` and `useSelector` is observed.\n\n### Usage Example\n\n```typescript\nimport { useDispatch, useSelector } from 'react-redux';\nimport { RootState } from '@/redux/store';\nimport { setUser } from '@/redux/slices/AuthSlice';\n\nconst Component = () => {\n  const dispatch = useDispatch();\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const handleLogin = (user: User) => {\n    dispatch(setUser(user));\n  };\n\n  return <div>{user ? `Welcome, ${user.name}` : 'Please log in'}</div>;\n};\n```\n\n## Component Patterns\n\n### Page Structure\n\nPages are structured with layout components and authorization guards. For example, the `Parcels` page:\n\n```typescript\n/** @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\nimport { useState, useCallback } from 'react';\nimport { Input, Select, Button, Tag, Space, Modal, Typography, message } from 'antd';\nimport { SearchOutlined, ReloadOutlined } from '@ant-design/icons';\nimport type { ColumnsType } from 'antd/es/table';\nimport Authorize from '@/components/authorize/Authorize';\nimport AppLayout from '@/components/layout/AppLayout';\nimport TableRenderer from '@/components/table/TableRenderer';\nimport { useTable } from '@/hooks/useTable';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel, FetchParcelsParams } from '@/types/parcel';\n\nconst { Title, Text } = Typography;\n\nconst searchBarStyle = css`\n  display: flex;\n  gap: 12px;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n  align-items: flex-end;\n`;\n\nconst Parcels = () => {\n  // Component logic\n};\n\nexport default Parcels;\n```\n\n### Permission-Based Conditional Rendering\n\nComponents like `Authorize` are used to wrap content that requires access control:\n\n```typescript\nimport Authorize from '@/components/authorize/Authorize';\n\nconst ProtectedComponent = () => (\n  <Authorize roles={['Admin', 'User']}>\n    <div>Protected Content</div>\n  </Authorize>\n);\n```\n\n### Primary Form Handling Pattern\n\nForms are handled using Ant Design's `Form` component. Example from `src/pages/Login.tsx`:\n\n```typescript\nimport { Form, Input, Button, message } from 'antd';\n\nconst LoginForm = () => {\n  const [form] = Form.useForm();\n\n  const handleSubmit = async () => {\n    try {\n      const values = await form.validateFields();\n      // Handle login\n    } catch (error) {\n      message.error('Validation failed');\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\">\n      <Form.Item name=\"username\" label=\"Username\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Form.Item name=\"password\" label=\"Password\" rules={[{ required: true }]}>\n        <Input.Password />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSubmit}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n```\n\n### Table/Data-Grid Pattern\n\nTables are rendered using custom hooks and components. Example from `src/components/table/TableRenderer.tsx`:\n\n```typescript\nimport { Table } from 'antd';\nimport { useTable } from '@/hooks/useTable';\nimport { Parcel } from '@/types/parcel';\n\nconst TableRenderer = () => {\n  const { data, loading, onPaginationChange } = useTable<Parcel, FetchParcelsParams>({\n    initialParams: { limit: 10, offset: 0 },\n    fetchFn: fetchParcels,\n  });\n\n  return (\n    <Table\n      dataSource={data}\n      loading={loading}\n      pagination={{ onChange: onPaginationChange }}\n      // Define columns\n    />\n  );\n};\n```\n\n### Styling Approach\n\nThe project uses Emotion for styling components. Example from `src/assets/globalStyles.ts`:\n\n```typescript\nimport { css } from '@emotion/react';\n\nexport const globalStyles = css`\n  body {\n    margin: 0;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: #f5f5f5;\n  }\n\n  #root {\n    min-height: 100vh;\n  }\n`;\n```\n\n## API Integration\n\n### HTTP Client Configuration\n\nThe project uses Axios for HTTP requests. The Axios instance is configured in `src/services/axios.config.ts`:\n\n```typescript\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n  baseURL: 'https://dummy-api.redx.local',\n  timeout: 5000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nexport default apiClient;\n```\n\n### Service Layer Pattern\n\nService modules encapsulate API calls. Example from `src/services/parcelAPI.ts`:\n\n```typescript\nimport apiClient from './axios.config';\nimport { FetchParcelsParams, FetchParcelsResponse } from '@/types/parcel';\n\nexport const fetchParcels = async (params: FetchParcelsParams): Promise<FetchParcelsResponse> => {\n  const response = await apiClient.get('/parcels', { params });\n  return response.data;\n};\n```\n\n### Error Handling\n\nError handling is typically done using try/catch blocks with user feedback via Ant Design's `message` component:\n\n```typescript\nimport { message } from 'antd';\n\nconst fetchData = async () => {\n  try {\n    const response = await apiClient.get('/data');\n    // Handle response\n  } catch (error) {\n    message.error('Failed to fetch data');\n  }\n};\n```\n\n## Navigation & Routing\n\nThe project uses React Router for navigation. The routing configuration is defined in `src/App.tsx`:\n\n```typescript\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport Login from '@/pages/Login';\nimport Parcels from '@/pages/Parcels';\nimport NotFound from '@/pages/NotFound';\n\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<Navigate to=\"/parcels\" replace />} />\n      <Route path=\"/login\" element={<Login />} />\n      <Route path=\"/parcels\" element={<Parcels />} />\n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  </BrowserRouter>\n);\n\nexport default App;\n```\n\n### Menu/Navigation Configuration\n\nNavigation items are defined in `src/config/navigation.ts`:\n\n```typescript\nexport interface NavItem {\n  key: string;\n  label: string;\n  path: string;\n  roles: string[];\n}\n\nexport const navigationItems: NavItem[] = [\n  {\n    key: 'parcels',\n    label: 'Parcels',\n    path: '/parcels',\n    roles: ['RedX Super Admin', 'RedX Finance Team'],\n  },\n];\n```\n\n## Authentication & Authorization\n\n### Authentication Flow\n\nThe authentication flow involves sending an OTP to the user's phone and verifying it. Example from `src/pages/Login.tsx`:\n\n```typescript\nimport { useState } from 'react';\nimport { Form, Input, Button, message } from 'antd';\nimport { useDispatch } from 'react-redux';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { requestLoginOtp, verifyOtp } from '@/services/authAPI';\n\nconst Login = () => {\n  const [loading, setLoading] = useState(false);\n  const [otpSent, setOtpSent] = useState(false);\n  const [form] = Form.useForm();\n  const dispatch = useDispatch();\n\n  const handleSendOtp = async () => {\n    try {\n      const phone = form.getFieldValue('phone');\n      if (!phone) {\n        message.error('Please enter phone number');\n        return;\n      }\n      setLoading(true);\n      await requestLoginOtp({ phone });\n      message.success('OTP sent successfully!');\n      setOtpSent(true);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleLogin = async () => {\n    try {\n      const values = await form.validateFields();\n      setLoading(true);\n      const res = await verifyOtp({\n        phone: values.phone,\n        otp: values.otp,\n      });\n      if (res.success && res.user) {\n        dispatch(setUser(res.user));\n        message.success('Login successful!');\n      } else {\n        message.error(res.error || 'Login failed');\n      }\n    } catch {\n      // validation error\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\">\n      <Form.Item name=\"phone\" label=\"Phone Number\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Form.Item name=\"otp\" label=\"OTP\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSendOtp} loading={loading}>\n        Send OTP\n      </Button>\n      <Button type=\"primary\" onClick={handleLogin} loading={loading} disabled={!otpSent}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n\nexport default Login;\n```\n\n### Authorization Patterns\n\nAuthorization is handled using hooks and components. Example from `src/hooks/useAuthorization.ts`:\n\n```typescript\nimport { useSelector } from 'react-redux';\nimport { RootState } from '@/redux/store';\n\nexport const useAuthorization = ({ roles }: { roles: string[] }) => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) => userRoleNames.includes(role));\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n## Common Utilities\n\n### Utility Modules\n\n- **Form Helpers** (`src/lib/formHelpers.ts`)\n\n  ```typescript\n  export const handleNumericValueChange = (value: string): string => {\n    return value.replace(/[^0-9]/g, '');\n  };\n\n  export const disableFutureDates = (current: Dayjs): boolean => {\n    return current && current.valueOf() > Date.now();\n  };\n  ```\n\n- **Utils** (`src/lib/utils.ts`)\n\n  ```typescript\n  import { twMerge } from 'tailwind-merge';\n  import clsx from 'clsx';\n\n  export function cn(...inputs: ClassValue[]) {\n    return twMerge(clsx(inputs));\n  }\n  ```\n\n## Testing & Quality\n\n### Testing Framework\n\nThe project uses Vitest for testing. The configuration is defined in `vitest.config.ts`:\n\n```typescript\nimport { defineConfig } from 'vitest/config';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: ['./src/test/setup.ts'],\n    include: ['src/**/*.{test,spec}.{ts,tsx}'],\n  },\n  resolve: {\n    alias: { '@': path.resolve(__dirname, './src') },\n  },\n});\n```\n\n### Test-ID Conventions\n\nTest IDs are used in form inputs for testing purposes:\n\n```typescript\n<Form.Item name=\"phone\" label=\"Phone Number\" rules={[{ required: true }]}>\n  <Input data-testid=\"phone-input\" />\n</Form.Item>\n```\n\n### Lint/Test/Type-Check Commands\n\nThe project does not have specific linting or type-checking commands configured. Testing can be run using Vitest:\n\n```bash\nvitest run\n```\n\n## Environment Variables\n\nThe project does not specify any required environment variables in the DNA snapshot.\n\n## Development Workflow\n\n### Local Development\n\nTo set up the project locally, use the following commands:\n\n```bash\n# Install dependencies\nnpm install\n\n# Start the development server\nnpm run dev\n\n# Build the project\nnpm run build\n\n# Start the production server\nnpm start\n```\n\n### Local Setup Requirements\n\n- Node.js version: 16.x or higher\n- Package manager: npm\n- External services: None specified\n\n### Git Workflow\n\nThe project does not specify a conventional commits format or branch naming convention. There is no CI/CD pipeline evident in the DNA snapshot.\n\n## Performance Considerations\n\n### Code Splitting\n\nThe project does not specify a code splitting strategy in the DNA snapshot.\n\n### Lazy Loading\n\nLazy loading is not explicitly mentioned in the DNA snapshot.\n\n### Tree Shaking\n\nTree shaking is not explicitly mentioned in the DNA snapshot.\n\n### Bundle Analysis Tools\n\nBundle analysis tools are not explicitly mentioned in the DNA snapshot.\n\n## Common Patterns to Follow\n\n1. Use Emotion for styling components.\n2. Wrap route content with `Authorize` where access control is required.\n3. Prefer Ant Design components for consistent UI patterns.\n4. Use `useTable` hook for table data management.\n5. Use `apiClient` for all HTTP requests.\n6. Define navigation items in `src/config/navigation.ts`.\n7. Use `useAuthorization` hook for role-based access control.\n8. Handle form submissions using Ant Design's `Form` component.\n9. Use `message` component from Ant Design for user feedback.\n10. Define Redux slices using `createSlice` from Redux Toolkit.\n11. Use `persistStore` for Redux state persistence.\n12. Use `useDispatch` and `useSelector` for Redux state management.\n\n## Domain-Specific Features\n\n### Parcel Management\n\n- **Purpose**: Manage parcel tracking and status updates.\n- **Key Components**: `Parcels` page, `TableRenderer` component, `useTable` hook.\n- **Special Patterns**: Use of `useTable` hook for pagination and data fetching.\n\n## Debugging & Development Tools\n\n### DevTools Integration\n\n- **Redux DevTools**: Not explicitly mentioned, but can be integrated for state debugging.\n- **React DevTools**: Can be used for component inspection.\n\n### Logging Patterns\n\nLogging is done using `console.error` for error tracking, as seen in `src/pages/NotFound.tsx`.\n\n### Source Maps\n\nSource maps are not explicitly mentioned in the DNA snapshot.\n\n## Migration Notes\n\nNo ongoing migrations are detected in the DNA snapshot.\n\n## Best Practices\n\n1. Use design tokens for consistent theming.\n2. Avoid using hex colors directly; use design tokens instead.\n3. Ensure all pages are wrapped with `Authorize` where necessary.\n4. Use Ant Design components for form handling.\n5. Keep API service logic encapsulated in service modules.\n6. Use `useCallback` and `useEffect` hooks for performance optimization.\n7. Ensure all components are styled using Emotion.\n8. Use TypeScript interfaces for type safety.\n9. Maintain a consistent import order across files.\n10. Use `message` component for consistent user feedback.\n\nRemember: The RedX Admin Hub is designed to streamline administrative tasks for the RedX logistics platform, ensuring efficient parcel management and user access control."
    },
    "component_creation": {
      "purpose": "Component Creation",
      "systemPrompt": "# GitHub Copilot Instructions for RedX Admin Hub\n\n---\n\n## applyTo: '**'\n\nThis file serves as the authoritative guide for AI coding assistants working on the RedX Admin Hub project. It provides comprehensive instructions and conventions that must be followed to ensure consistency and quality across the codebase. AI coding assistants should use this document as the primary reference for understanding the project's architecture, coding standards, and development practices.\n\n## Project Overview\n\nThe RedX Admin Hub is a web-based application designed to manage administrative tasks for the RedX logistics platform. Its primary users are internal staff members, including administrators and finance teams, who require access to parcel tracking, user management, and reporting features. The project is built using React and TypeScript, with a focus on providing a responsive and user-friendly interface. The application leverages Ant Design for UI components and Redux Toolkit for state management, ensuring a scalable and maintainable codebase.\n\n## Architecture & Technology Stack\n\n### Core Technologies\n\n- **React**: A JavaScript library for building user interfaces.\n- **TypeScript**: A typed superset of JavaScript that compiles to plain JavaScript.\n- **Ant Design**: A UI library providing a set of high-quality React components.\n- **Emotion**: A library for writing CSS styles with JavaScript.\n- **Redux Toolkit**: A library for managing application state using Redux.\n- **Axios**: A promise-based HTTP client for making requests to the server.\n\n### Project Structure\n\n```plaintext\n├── .gitignore\n├── bun.lockb\n├── components.json\n├── eslint.config.js\n├── index.html\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── README.md\n├── tailwind.config.ts\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.node.json\n├── vite.config.ts\n├── vitest.config.ts\n├── public\n│   ├── favicon.ico\n│   ├── placeholder.svg\n│   └── robots.txt\n└── src\n    ├── assets\n    │   └── globalStyles.ts\n    ├── components\n    │   ├── authorize\n    │   │   └── Authorize.tsx\n    │   ├── layout\n    │   │   └── AppLayout.tsx\n    │   ├── table\n    │   │   └── TableRenderer.tsx\n    │   └── ui\n    │       ├── accordion.tsx\n    │       ├── alert-dialog.tsx\n    │       ├── alert.tsx\n    │       ├── aspect-ratio.tsx\n    │       ├── avatar.tsx\n    │       ├── badge.tsx\n    │       ├── breadcrumb.tsx\n    │       ├── button.tsx\n    │       ├── calendar.tsx\n    │       ├── card.tsx\n    │       ├── carousel.tsx\n    │       ├── chart.tsx\n    │       ├── checkbox.tsx\n    │       ├── collapsible.tsx\n    │       ├── command.tsx\n    │       ├── context-menu.tsx\n    │       ├── dialog.tsx\n    │       ├── drawer.tsx\n    │       ├── dropdown-menu.tsx\n    │       ├── form.tsx\n    │       ├── hover-card.tsx\n    │       ├── input-otp.tsx\n    │       ├── input.tsx\n    │       ├── label.tsx\n    │       ├── menubar.tsx\n    │       ├── navigation-menu.tsx\n    │       ├── pagination.tsx\n    │       ├── popover.tsx\n    │       ├── progress.tsx\n    │       ├── radio-group.tsx\n    │       ├── resizable.tsx\n    │       ├── scroll-area.tsx\n    │       ├── select.tsx\n    │       ├── separator.tsx\n    │       ├── sheet.tsx\n    │       ├── sidebar.tsx\n    │       ├── skeleton.tsx\n    │       ├── slider.tsx\n    │       ├── sonner.tsx\n    │       ├── switch.tsx\n    │       ├── table.tsx\n    │       ├── tabs.tsx\n    │       ├── textarea.tsx\n    │       ├── toast.tsx\n    │       ├── toaster.tsx\n    │       ├── toggle-group.tsx\n    │       ├── toggle.tsx\n    │       └── tooltip.tsx\n    ├── config\n    │   ├── getPagePermissions.ts\n    │   ├── local.ts\n    │   └── navigation.ts\n    ├── hooks\n    │   ├── use-mobile.tsx\n    │   ├── use-toast.ts\n    │   ├── useAuthorization.ts\n    │   └── useTable.ts\n    ├── pages\n    │   ├── Index.tsx\n    │   ├── Login.tsx\n    │   ├── NotFound.tsx\n    │   └── Parcels.tsx\n    ├── redux\n    │   ├── slices\n    │   │   └── AuthSlice.ts\n    │   └── store.ts\n    ├── services\n    │   ├── authAPI.ts\n    │   ├── axios.config.ts\n    │   └── parcelAPI.ts\n    ├── test\n    │   ├── example.test.ts\n    │   └── setup.ts\n    └── types\n        ├── auth.ts\n        └── parcel.ts\n```\n\n## Code Style & Standards\n\n### Formatting & Linting\n\nThe project does not currently use Prettier or ESLint for code formatting and linting. However, TypeScript is configured with the following settings:\n\n```json\n{\n  \"strict\": false,\n  \"jsx\": null,\n  \"baseUrl\": \".\",\n  \"pathAliases\": {\n    \"@/*\": [\n      \"./src/*\"\n    ]\n  }\n}\n```\n\nFile naming conventions follow camelCase for files and PascalCase for components. There is no commitlint configuration present.\n\n### Import Organization\n\nThe preferred import order is as follows:\n\n1. Framework imports (e.g., React)\n2. UI library imports (e.g., Ant Design)\n3. Third-party library imports\n4. Local hooks\n5. Redux/state imports\n6. Services\n7. Constants\n8. Types\n\nExample:\n\n```typescript\nimport React, { useState } from 'react';\nimport { Button, Input } from 'antd';\nimport axios from 'axios';\nimport { useTable } from '@/hooks/useTable';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel } from '@/types/parcel';\n```\n\n## State Management\n\nThe project uses Redux Toolkit for state management.\n\n### Redux Toolkit Configuration\n\nThe Redux store is configured in `src/redux/store.ts`:\n\n```typescript\nimport { configureStore } from '@reduxjs/toolkit';\nimport { persistStore } from 'redux-persist';\nimport persistedReducer from './reducers';\n\nexport const store = configureStore({\n  reducer: persistedReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n      },\n    }),\n});\n\nexport const persistor = persistStore(store);\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n```\n\n### Redux Slice Example\n\nThe `auth` slice is defined in `src/redux/slices/AuthSlice.ts`:\n\n```typescript\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { AuthState, User } from '@/types/auth';\n\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    setUser(state, action: PayloadAction<User>) {\n      state.user = action.payload;\n      state.isAuthenticated = true;\n    },\n    clearAuth(state) {\n      state.user = null;\n      state.isAuthenticated = false;\n    },\n  },\n});\n\nexport const { setUser, clearAuth } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\n### Typed Hooks\n\nTyped hooks such as `useAppDispatch` and `useAppSelector` are not used in this project. Instead, direct usage of `useDispatch` and `useSelector` is observed.\n\n### Usage Example\n\n```typescript\nimport { useDispatch, useSelector } from 'react-redux';\nimport { RootState } from '@/redux/store';\nimport { setUser } from '@/redux/slices/AuthSlice';\n\nconst Component = () => {\n  const dispatch = useDispatch();\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const handleLogin = (user: User) => {\n    dispatch(setUser(user));\n  };\n\n  return <div>{user ? `Welcome, ${user.name}` : 'Please log in'}</div>;\n};\n```\n\n## Component Patterns\n\n### Page Structure\n\nPages are structured with layout components and authorization guards. For example, the `Parcels` page:\n\n```typescript\n/** @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\nimport { useState, useCallback } from 'react';\nimport { Input, Select, Button, Tag, Space, Modal, Typography, message } from 'antd';\nimport { SearchOutlined, ReloadOutlined } from '@ant-design/icons';\nimport type { ColumnsType } from 'antd/es/table';\nimport Authorize from '@/components/authorize/Authorize';\nimport AppLayout from '@/components/layout/AppLayout';\nimport TableRenderer from '@/components/table/TableRenderer';\nimport { useTable } from '@/hooks/useTable';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel, FetchParcelsParams } from '@/types/parcel';\n\nconst { Title, Text } = Typography;\n\nconst searchBarStyle = css`\n  display: flex;\n  gap: 12px;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n  align-items: flex-end;\n`;\n\nconst Parcels = () => {\n  // Component logic\n};\n\nexport default Parcels;\n```\n\n### Permission-Based Conditional Rendering\n\nComponents like `Authorize` are used to wrap content that requires access control:\n\n```typescript\nimport Authorize from '@/components/authorize/Authorize';\n\nconst ProtectedComponent = () => (\n  <Authorize roles={['Admin', 'User']}>\n    <div>Protected Content</div>\n  </Authorize>\n);\n```\n\n### Primary Form Handling Pattern\n\nForms are handled using Ant Design's `Form` component. Example from `src/pages/Login.tsx`:\n\n```typescript\nimport { Form, Input, Button, message } from 'antd';\n\nconst LoginForm = () => {\n  const [form] = Form.useForm();\n\n  const handleSubmit = async () => {\n    try {\n      const values = await form.validateFields();\n      // Handle login\n    } catch (error) {\n      message.error('Validation failed');\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\">\n      <Form.Item name=\"username\" label=\"Username\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Form.Item name=\"password\" label=\"Password\" rules={[{ required: true }]}>\n        <Input.Password />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSubmit}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n```\n\n### Table/Data-Grid Pattern\n\nTables are rendered using custom hooks and components. Example from `src/components/table/TableRenderer.tsx`:\n\n```typescript\nimport { Table } from 'antd';\nimport { useTable } from '@/hooks/useTable';\nimport { Parcel } from '@/types/parcel';\n\nconst TableRenderer = () => {\n  const { data, loading, onPaginationChange } = useTable<Parcel, FetchParcelsParams>({\n    initialParams: { limit: 10, offset: 0 },\n    fetchFn: fetchParcels,\n  });\n\n  return (\n    <Table\n      dataSource={data}\n      loading={loading}\n      pagination={{ onChange: onPaginationChange }}\n      // Define columns\n    />\n  );\n};\n```\n\n### Styling Approach\n\nThe project uses Emotion for styling components. Example from `src/assets/globalStyles.ts`:\n\n```typescript\nimport { css } from '@emotion/react';\n\nexport const globalStyles = css`\n  body {\n    margin: 0;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: #f5f5f5;\n  }\n\n  #root {\n    min-height: 100vh;\n  }\n`;\n```\n\n## API Integration\n\n### HTTP Client Configuration\n\nThe project uses Axios for HTTP requests. The Axios instance is configured in `src/services/axios.config.ts`:\n\n```typescript\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n  baseURL: 'https://dummy-api.redx.local',\n  timeout: 5000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nexport default apiClient;\n```\n\n### Service Layer Pattern\n\nService modules encapsulate API calls. Example from `src/services/parcelAPI.ts`:\n\n```typescript\nimport apiClient from './axios.config';\nimport { FetchParcelsParams, FetchParcelsResponse } from '@/types/parcel';\n\nexport const fetchParcels = async (params: FetchParcelsParams): Promise<FetchParcelsResponse> => {\n  const response = await apiClient.get('/parcels', { params });\n  return response.data;\n};\n```\n\n### Error Handling\n\nError handling is typically done using try/catch blocks with user feedback via Ant Design's `message` component:\n\n```typescript\nimport { message } from 'antd';\n\nconst fetchData = async () => {\n  try {\n    const response = await apiClient.get('/data');\n    // Handle response\n  } catch (error) {\n    message.error('Failed to fetch data');\n  }\n};\n```\n\n## Navigation & Routing\n\nThe project uses React Router for navigation. The routing configuration is defined in `src/App.tsx`:\n\n```typescript\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport Login from '@/pages/Login';\nimport Parcels from '@/pages/Parcels';\nimport NotFound from '@/pages/NotFound';\n\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<Navigate to=\"/parcels\" replace />} />\n      <Route path=\"/login\" element={<Login />} />\n      <Route path=\"/parcels\" element={<Parcels />} />\n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  </BrowserRouter>\n);\n\nexport default App;\n```\n\n### Menu/Navigation Configuration\n\nNavigation items are defined in `src/config/navigation.ts`:\n\n```typescript\nexport interface NavItem {\n  key: string;\n  label: string;\n  path: string;\n  roles: string[];\n}\n\nexport const navigationItems: NavItem[] = [\n  {\n    key: 'parcels',\n    label: 'Parcels',\n    path: '/parcels',\n    roles: ['RedX Super Admin', 'RedX Finance Team'],\n  },\n];\n```\n\n## Authentication & Authorization\n\n### Authentication Flow\n\nThe authentication flow involves sending an OTP to the user's phone and verifying it. Example from `src/pages/Login.tsx`:\n\n```typescript\nimport { useState } from 'react';\nimport { Form, Input, Button, message } from 'antd';\nimport { useDispatch } from 'react-redux';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { requestLoginOtp, verifyOtp } from '@/services/authAPI';\n\nconst Login = () => {\n  const [loading, setLoading] = useState(false);\n  const [otpSent, setOtpSent] = useState(false);\n  const [form] = Form.useForm();\n  const dispatch = useDispatch();\n\n  const handleSendOtp = async () => {\n    try {\n      const phone = form.getFieldValue('phone');\n      if (!phone) {\n        message.error('Please enter phone number');\n        return;\n      }\n      setLoading(true);\n      await requestLoginOtp({ phone });\n      message.success('OTP sent successfully!');\n      setOtpSent(true);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleLogin = async () => {\n    try {\n      const values = await form.validateFields();\n      setLoading(true);\n      const res = await verifyOtp({\n        phone: values.phone,\n        otp: values.otp,\n      });\n      if (res.success && res.user) {\n        dispatch(setUser(res.user));\n        message.success('Login successful!');\n      } else {\n        message.error(res.error || 'Login failed');\n      }\n    } catch {\n      // validation error\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\">\n      <Form.Item name=\"phone\" label=\"Phone Number\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Form.Item name=\"otp\" label=\"OTP\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSendOtp} loading={loading}>\n        Send OTP\n      </Button>\n      <Button type=\"primary\" onClick={handleLogin} loading={loading} disabled={!otpSent}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n\nexport default Login;\n```\n\n### Authorization Patterns\n\nAuthorization is handled using hooks and components. Example from `src/hooks/useAuthorization.ts`:\n\n```typescript\nimport { useSelector } from 'react-redux';\nimport { RootState } from '@/redux/store';\n\nexport const useAuthorization = ({ roles }: { roles: string[] }) => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) => userRoleNames.includes(role));\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n## Common Utilities\n\n### Utility Modules\n\n- **Form Helpers** (`src/lib/formHelpers.ts`)\n\n  ```typescript\n  export const handleNumericValueChange = (value: string): string => {\n    return value.replace(/[^0-9]/g, '');\n  };\n\n  export const disableFutureDates = (current: Dayjs): boolean => {\n    return current && current.valueOf() > Date.now();\n  };\n  ```\n\n- **Utils** (`src/lib/utils.ts`)\n\n  ```typescript\n  import { twMerge } from 'tailwind-merge';\n  import clsx from 'clsx';\n\n  export function cn(...inputs: ClassValue[]) {\n    return twMerge(clsx(inputs));\n  }\n  ```\n\n## Testing & Quality\n\n### Testing Framework\n\nThe project uses Vitest for testing. The configuration is defined in `vitest.config.ts`:\n\n```typescript\nimport { defineConfig } from 'vitest/config';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: ['./src/test/setup.ts'],\n    include: ['src/**/*.{test,spec}.{ts,tsx}'],\n  },\n  resolve: {\n    alias: { '@': path.resolve(__dirname, './src') },\n  },\n});\n```\n\n### Test-ID Conventions\n\nTest IDs are used in form inputs for testing purposes:\n\n```typescript\n<Form.Item name=\"phone\" label=\"Phone Number\" rules={[{ required: true }]}>\n  <Input data-testid=\"phone-input\" />\n</Form.Item>\n```\n\n### Lint/Test/Type-Check Commands\n\nThe project does not have specific linting or type-checking commands configured. Testing can be run using Vitest:\n\n```bash\nvitest run\n```\n\n## Environment Variables\n\nThe project does not specify any required environment variables in the DNA snapshot.\n\n## Development Workflow\n\n### Local Development\n\nTo set up the project locally, use the following commands:\n\n```bash\n# Install dependencies\nnpm install\n\n# Start the development server\nnpm run dev\n\n# Build the project\nnpm run build\n\n# Start the production server\nnpm start\n```\n\n### Local Setup Requirements\n\n- Node.js version: 16.x or higher\n- Package manager: npm\n- External services: None specified\n\n### Git Workflow\n\nThe project does not specify a conventional commits format or branch naming convention. There is no CI/CD pipeline evident in the DNA snapshot.\n\n## Performance Considerations\n\n### Code Splitting\n\nThe project does not specify a code splitting strategy in the DNA snapshot.\n\n### Lazy Loading\n\nLazy loading is not explicitly mentioned in the DNA snapshot.\n\n### Tree Shaking\n\nTree shaking is not explicitly mentioned in the DNA snapshot.\n\n### Bundle Analysis Tools\n\nBundle analysis tools are not explicitly mentioned in the DNA snapshot.\n\n## Common Patterns to Follow\n\n1. Use Emotion for styling components.\n2. Wrap route content with `Authorize` where access control is required.\n3. Prefer Ant Design components for consistent UI patterns.\n4. Use `useTable` hook for table data management.\n5. Use `apiClient` for all HTTP requests.\n6. Define navigation items in `src/config/navigation.ts`.\n7. Use `useAuthorization` hook for role-based access control.\n8. Handle form submissions using Ant Design's `Form` component.\n9. Use `message` component from Ant Design for user feedback.\n10. Define Redux slices using `createSlice` from Redux Toolkit.\n11. Use `persistStore` for Redux state persistence.\n12. Use `useDispatch` and `useSelector` for Redux state management.\n\n## Domain-Specific Features\n\n### Parcel Management\n\n- **Purpose**: Manage parcel tracking and status updates.\n- **Key Components**: `Parcels` page, `TableRenderer` component, `useTable` hook.\n- **Special Patterns**: Use of `useTable` hook for pagination and data fetching.\n\n## Debugging & Development Tools\n\n### DevTools Integration\n\n- **Redux DevTools**: Not explicitly mentioned, but can be integrated for state debugging.\n- **React DevTools**: Can be used for component inspection.\n\n### Logging Patterns\n\nLogging is done using `console.error` for error tracking, as seen in `src/pages/NotFound.tsx`.\n\n### Source Maps\n\nSource maps are not explicitly mentioned in the DNA snapshot.\n\n## Migration Notes\n\nNo ongoing migrations are detected in the DNA snapshot.\n\n## Best Practices\n\n1. Use design tokens for consistent theming.\n2. Avoid using hex colors directly; use design tokens instead.\n3. Ensure all pages are wrapped with `Authorize` where necessary.\n4. Use Ant Design components for form handling.\n5. Keep API service logic encapsulated in service modules.\n6. Use `useCallback` and `useEffect` hooks for performance optimization.\n7. Ensure all components are styled using Emotion.\n8. Use TypeScript interfaces for type safety.\n9. Maintain a consistent import order across files.\n10. Use `message` component for consistent user feedback.\n\nRemember: The RedX Admin Hub is designed to streamline administrative tasks for the RedX logistics platform, ensuring efficient parcel management and user access control."
    },
    "api_integration": {
      "purpose": "API Integration",
      "systemPrompt": "# GitHub Copilot Instructions for RedX Admin Hub\n\n---\n\n## applyTo: '**'\n\nThis file serves as the authoritative guide for AI coding assistants working on the RedX Admin Hub project. It provides comprehensive instructions and conventions that must be followed to ensure consistency and quality across the codebase. AI coding assistants should use this document as the primary reference for understanding the project's architecture, coding standards, and development practices.\n\n## Project Overview\n\nThe RedX Admin Hub is a web-based application designed to manage administrative tasks for the RedX logistics platform. Its primary users are internal staff members, including administrators and finance teams, who require access to parcel tracking, user management, and reporting features. The project is built using React and TypeScript, with a focus on providing a responsive and user-friendly interface. The application leverages Ant Design for UI components and Redux Toolkit for state management, ensuring a scalable and maintainable codebase.\n\n## Architecture & Technology Stack\n\n### Core Technologies\n\n- **React**: A JavaScript library for building user interfaces.\n- **TypeScript**: A typed superset of JavaScript that compiles to plain JavaScript.\n- **Ant Design**: A UI library providing a set of high-quality React components.\n- **Emotion**: A library for writing CSS styles with JavaScript.\n- **Redux Toolkit**: A library for managing application state using Redux.\n- **Axios**: A promise-based HTTP client for making requests to the server.\n\n### Project Structure\n\n```plaintext\n├── .gitignore\n├── bun.lockb\n├── components.json\n├── eslint.config.js\n├── index.html\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── README.md\n├── tailwind.config.ts\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.node.json\n├── vite.config.ts\n├── vitest.config.ts\n├── public\n│   ├── favicon.ico\n│   ├── placeholder.svg\n│   └── robots.txt\n└── src\n    ├── assets\n    │   └── globalStyles.ts\n    ├── components\n    │   ├── authorize\n    │   │   └── Authorize.tsx\n    │   ├── layout\n    │   │   └── AppLayout.tsx\n    │   ├── table\n    │   │   └── TableRenderer.tsx\n    │   └── ui\n    │       ├── accordion.tsx\n    │       ├── alert-dialog.tsx\n    │       ├── alert.tsx\n    │       ├── aspect-ratio.tsx\n    │       ├── avatar.tsx\n    │       ├── badge.tsx\n    │       ├── breadcrumb.tsx\n    │       ├── button.tsx\n    │       ├── calendar.tsx\n    │       ├── card.tsx\n    │       ├── carousel.tsx\n    │       ├── chart.tsx\n    │       ├── checkbox.tsx\n    │       ├── collapsible.tsx\n    │       ├── command.tsx\n    │       ├── context-menu.tsx\n    │       ├── dialog.tsx\n    │       ├── drawer.tsx\n    │       ├── dropdown-menu.tsx\n    │       ├── form.tsx\n    │       ├── hover-card.tsx\n    │       ├── input-otp.tsx\n    │       ├── input.tsx\n    │       ├── label.tsx\n    │       ├── menubar.tsx\n    │       ├── navigation-menu.tsx\n    │       ├── pagination.tsx\n    │       ├── popover.tsx\n    │       ├── progress.tsx\n    │       ├── radio-group.tsx\n    │       ├── resizable.tsx\n    │       ├── scroll-area.tsx\n    │       ├── select.tsx\n    │       ├── separator.tsx\n    │       ├── sheet.tsx\n    │       ├── sidebar.tsx\n    │       ├── skeleton.tsx\n    │       ├── slider.tsx\n    │       ├── sonner.tsx\n    │       ├── switch.tsx\n    │       ├── table.tsx\n    │       ├── tabs.tsx\n    │       ├── textarea.tsx\n    │       ├── toast.tsx\n    │       ├── toaster.tsx\n    │       ├── toggle-group.tsx\n    │       ├── toggle.tsx\n    │       └── tooltip.tsx\n    ├── config\n    │   ├── getPagePermissions.ts\n    │   ├── local.ts\n    │   └── navigation.ts\n    ├── hooks\n    │   ├── use-mobile.tsx\n    │   ├── use-toast.ts\n    │   ├── useAuthorization.ts\n    │   └── useTable.ts\n    ├── pages\n    │   ├── Index.tsx\n    │   ├── Login.tsx\n    │   ├── NotFound.tsx\n    │   └── Parcels.tsx\n    ├── redux\n    │   ├── slices\n    │   │   └── AuthSlice.ts\n    │   └── store.ts\n    ├── services\n    │   ├── authAPI.ts\n    │   ├── axios.config.ts\n    │   └── parcelAPI.ts\n    ├── test\n    │   ├── example.test.ts\n    │   └── setup.ts\n    └── types\n        ├── auth.ts\n        └── parcel.ts\n```\n\n## Code Style & Standards\n\n### Formatting & Linting\n\nThe project does not currently use Prettier or ESLint for code formatting and linting. However, TypeScript is configured with the following settings:\n\n```json\n{\n  \"strict\": false,\n  \"jsx\": null,\n  \"baseUrl\": \".\",\n  \"pathAliases\": {\n    \"@/*\": [\n      \"./src/*\"\n    ]\n  }\n}\n```\n\nFile naming conventions follow camelCase for files and PascalCase for components. There is no commitlint configuration present.\n\n### Import Organization\n\nThe preferred import order is as follows:\n\n1. Framework imports (e.g., React)\n2. UI library imports (e.g., Ant Design)\n3. Third-party library imports\n4. Local hooks\n5. Redux/state imports\n6. Services\n7. Constants\n8. Types\n\nExample:\n\n```typescript\nimport React, { useState } from 'react';\nimport { Button, Input } from 'antd';\nimport axios from 'axios';\nimport { useTable } from '@/hooks/useTable';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel } from '@/types/parcel';\n```\n\n## State Management\n\nThe project uses Redux Toolkit for state management.\n\n### Redux Toolkit Configuration\n\nThe Redux store is configured in `src/redux/store.ts`:\n\n```typescript\nimport { configureStore } from '@reduxjs/toolkit';\nimport { persistStore } from 'redux-persist';\nimport persistedReducer from './reducers';\n\nexport const store = configureStore({\n  reducer: persistedReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [FLUSH, REHYDRATE, PAUSE, PERSIST, PURGE, REGISTER],\n      },\n    }),\n});\n\nexport const persistor = persistStore(store);\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n```\n\n### Redux Slice Example\n\nThe `auth` slice is defined in `src/redux/slices/AuthSlice.ts`:\n\n```typescript\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { AuthState, User } from '@/types/auth';\n\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    setUser(state, action: PayloadAction<User>) {\n      state.user = action.payload;\n      state.isAuthenticated = true;\n    },\n    clearAuth(state) {\n      state.user = null;\n      state.isAuthenticated = false;\n    },\n  },\n});\n\nexport const { setUser, clearAuth } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\n### Typed Hooks\n\nTyped hooks such as `useAppDispatch` and `useAppSelector` are not used in this project. Instead, direct usage of `useDispatch` and `useSelector` is observed.\n\n### Usage Example\n\n```typescript\nimport { useDispatch, useSelector } from 'react-redux';\nimport { RootState } from '@/redux/store';\nimport { setUser } from '@/redux/slices/AuthSlice';\n\nconst Component = () => {\n  const dispatch = useDispatch();\n  const user = useSelector((state: RootState) => state.auth.user);\n\n  const handleLogin = (user: User) => {\n    dispatch(setUser(user));\n  };\n\n  return <div>{user ? `Welcome, ${user.name}` : 'Please log in'}</div>;\n};\n```\n\n## Component Patterns\n\n### Page Structure\n\nPages are structured with layout components and authorization guards. For example, the `Parcels` page:\n\n```typescript\n/** @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\nimport { useState, useCallback } from 'react';\nimport { Input, Select, Button, Tag, Space, Modal, Typography, message } from 'antd';\nimport { SearchOutlined, ReloadOutlined } from '@ant-design/icons';\nimport type { ColumnsType } from 'antd/es/table';\nimport Authorize from '@/components/authorize/Authorize';\nimport AppLayout from '@/components/layout/AppLayout';\nimport TableRenderer from '@/components/table/TableRenderer';\nimport { useTable } from '@/hooks/useTable';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel, FetchParcelsParams } from '@/types/parcel';\n\nconst { Title, Text } = Typography;\n\nconst searchBarStyle = css`\n  display: flex;\n  gap: 12px;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n  align-items: flex-end;\n`;\n\nconst Parcels = () => {\n  // Component logic\n};\n\nexport default Parcels;\n```\n\n### Permission-Based Conditional Rendering\n\nComponents like `Authorize` are used to wrap content that requires access control:\n\n```typescript\nimport Authorize from '@/components/authorize/Authorize';\n\nconst ProtectedComponent = () => (\n  <Authorize roles={['Admin', 'User']}>\n    <div>Protected Content</div>\n  </Authorize>\n);\n```\n\n### Primary Form Handling Pattern\n\nForms are handled using Ant Design's `Form` component. Example from `src/pages/Login.tsx`:\n\n```typescript\nimport { Form, Input, Button, message } from 'antd';\n\nconst LoginForm = () => {\n  const [form] = Form.useForm();\n\n  const handleSubmit = async () => {\n    try {\n      const values = await form.validateFields();\n      // Handle login\n    } catch (error) {\n      message.error('Validation failed');\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\">\n      <Form.Item name=\"username\" label=\"Username\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Form.Item name=\"password\" label=\"Password\" rules={[{ required: true }]}>\n        <Input.Password />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSubmit}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n```\n\n### Table/Data-Grid Pattern\n\nTables are rendered using custom hooks and components. Example from `src/components/table/TableRenderer.tsx`:\n\n```typescript\nimport { Table } from 'antd';\nimport { useTable } from '@/hooks/useTable';\nimport { Parcel } from '@/types/parcel';\n\nconst TableRenderer = () => {\n  const { data, loading, onPaginationChange } = useTable<Parcel, FetchParcelsParams>({\n    initialParams: { limit: 10, offset: 0 },\n    fetchFn: fetchParcels,\n  });\n\n  return (\n    <Table\n      dataSource={data}\n      loading={loading}\n      pagination={{ onChange: onPaginationChange }}\n      // Define columns\n    />\n  );\n};\n```\n\n### Styling Approach\n\nThe project uses Emotion for styling components. Example from `src/assets/globalStyles.ts`:\n\n```typescript\nimport { css } from '@emotion/react';\n\nexport const globalStyles = css`\n  body {\n    margin: 0;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: #f5f5f5;\n  }\n\n  #root {\n    min-height: 100vh;\n  }\n`;\n```\n\n## API Integration\n\n### HTTP Client Configuration\n\nThe project uses Axios for HTTP requests. The Axios instance is configured in `src/services/axios.config.ts`:\n\n```typescript\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n  baseURL: 'https://dummy-api.redx.local',\n  timeout: 5000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nexport default apiClient;\n```\n\n### Service Layer Pattern\n\nService modules encapsulate API calls. Example from `src/services/parcelAPI.ts`:\n\n```typescript\nimport apiClient from './axios.config';\nimport { FetchParcelsParams, FetchParcelsResponse } from '@/types/parcel';\n\nexport const fetchParcels = async (params: FetchParcelsParams): Promise<FetchParcelsResponse> => {\n  const response = await apiClient.get('/parcels', { params });\n  return response.data;\n};\n```\n\n### Error Handling\n\nError handling is typically done using try/catch blocks with user feedback via Ant Design's `message` component:\n\n```typescript\nimport { message } from 'antd';\n\nconst fetchData = async () => {\n  try {\n    const response = await apiClient.get('/data');\n    // Handle response\n  } catch (error) {\n    message.error('Failed to fetch data');\n  }\n};\n```\n\n## Navigation & Routing\n\nThe project uses React Router for navigation. The routing configuration is defined in `src/App.tsx`:\n\n```typescript\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport Login from '@/pages/Login';\nimport Parcels from '@/pages/Parcels';\nimport NotFound from '@/pages/NotFound';\n\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<Navigate to=\"/parcels\" replace />} />\n      <Route path=\"/login\" element={<Login />} />\n      <Route path=\"/parcels\" element={<Parcels />} />\n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  </BrowserRouter>\n);\n\nexport default App;\n```\n\n### Menu/Navigation Configuration\n\nNavigation items are defined in `src/config/navigation.ts`:\n\n```typescript\nexport interface NavItem {\n  key: string;\n  label: string;\n  path: string;\n  roles: string[];\n}\n\nexport const navigationItems: NavItem[] = [\n  {\n    key: 'parcels',\n    label: 'Parcels',\n    path: '/parcels',\n    roles: ['RedX Super Admin', 'RedX Finance Team'],\n  },\n];\n```\n\n## Authentication & Authorization\n\n### Authentication Flow\n\nThe authentication flow involves sending an OTP to the user's phone and verifying it. Example from `src/pages/Login.tsx`:\n\n```typescript\nimport { useState } from 'react';\nimport { Form, Input, Button, message } from 'antd';\nimport { useDispatch } from 'react-redux';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { requestLoginOtp, verifyOtp } from '@/services/authAPI';\n\nconst Login = () => {\n  const [loading, setLoading] = useState(false);\n  const [otpSent, setOtpSent] = useState(false);\n  const [form] = Form.useForm();\n  const dispatch = useDispatch();\n\n  const handleSendOtp = async () => {\n    try {\n      const phone = form.getFieldValue('phone');\n      if (!phone) {\n        message.error('Please enter phone number');\n        return;\n      }\n      setLoading(true);\n      await requestLoginOtp({ phone });\n      message.success('OTP sent successfully!');\n      setOtpSent(true);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleLogin = async () => {\n    try {\n      const values = await form.validateFields();\n      setLoading(true);\n      const res = await verifyOtp({\n        phone: values.phone,\n        otp: values.otp,\n      });\n      if (res.success && res.user) {\n        dispatch(setUser(res.user));\n        message.success('Login successful!');\n      } else {\n        message.error(res.error || 'Login failed');\n      }\n    } catch {\n      // validation error\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\">\n      <Form.Item name=\"phone\" label=\"Phone Number\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Form.Item name=\"otp\" label=\"OTP\" rules={[{ required: true }]}>\n        <Input />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSendOtp} loading={loading}>\n        Send OTP\n      </Button>\n      <Button type=\"primary\" onClick={handleLogin} loading={loading} disabled={!otpSent}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n\nexport default Login;\n```\n\n### Authorization Patterns\n\nAuthorization is handled using hooks and components. Example from `src/hooks/useAuthorization.ts`:\n\n```typescript\nimport { useSelector } from 'react-redux';\nimport { RootState } from '@/redux/store';\n\nexport const useAuthorization = ({ roles }: { roles: string[] }) => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) => userRoleNames.includes(role));\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n## Common Utilities\n\n### Utility Modules\n\n- **Form Helpers** (`src/lib/formHelpers.ts`)\n\n  ```typescript\n  export const handleNumericValueChange = (value: string): string => {\n    return value.replace(/[^0-9]/g, '');\n  };\n\n  export const disableFutureDates = (current: Dayjs): boolean => {\n    return current && current.valueOf() > Date.now();\n  };\n  ```\n\n- **Utils** (`src/lib/utils.ts`)\n\n  ```typescript\n  import { twMerge } from 'tailwind-merge';\n  import clsx from 'clsx';\n\n  export function cn(...inputs: ClassValue[]) {\n    return twMerge(clsx(inputs));\n  }\n  ```\n\n## Testing & Quality\n\n### Testing Framework\n\nThe project uses Vitest for testing. The configuration is defined in `vitest.config.ts`:\n\n```typescript\nimport { defineConfig } from 'vitest/config';\nimport react from '@vitejs/plugin-react';\n\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: ['./src/test/setup.ts'],\n    include: ['src/**/*.{test,spec}.{ts,tsx}'],\n  },\n  resolve: {\n    alias: { '@': path.resolve(__dirname, './src') },\n  },\n});\n```\n\n### Test-ID Conventions\n\nTest IDs are used in form inputs for testing purposes:\n\n```typescript\n<Form.Item name=\"phone\" label=\"Phone Number\" rules={[{ required: true }]}>\n  <Input data-testid=\"phone-input\" />\n</Form.Item>\n```\n\n### Lint/Test/Type-Check Commands\n\nThe project does not have specific linting or type-checking commands configured. Testing can be run using Vitest:\n\n```bash\nvitest run\n```\n\n## Environment Variables\n\nThe project does not specify any required environment variables in the DNA snapshot.\n\n## Development Workflow\n\n### Local Development\n\nTo set up the project locally, use the following commands:\n\n```bash\n# Install dependencies\nnpm install\n\n# Start the development server\nnpm run dev\n\n# Build the project\nnpm run build\n\n# Start the production server\nnpm start\n```\n\n### Local Setup Requirements\n\n- Node.js version: 16.x or higher\n- Package manager: npm\n- External services: None specified\n\n### Git Workflow\n\nThe project does not specify a conventional commits format or branch naming convention. There is no CI/CD pipeline evident in the DNA snapshot.\n\n## Performance Considerations\n\n### Code Splitting\n\nThe project does not specify a code splitting strategy in the DNA snapshot.\n\n### Lazy Loading\n\nLazy loading is not explicitly mentioned in the DNA snapshot.\n\n### Tree Shaking\n\nTree shaking is not explicitly mentioned in the DNA snapshot.\n\n### Bundle Analysis Tools\n\nBundle analysis tools are not explicitly mentioned in the DNA snapshot.\n\n## Common Patterns to Follow\n\n1. Use Emotion for styling components.\n2. Wrap route content with `Authorize` where access control is required.\n3. Prefer Ant Design components for consistent UI patterns.\n4. Use `useTable` hook for table data management.\n5. Use `apiClient` for all HTTP requests.\n6. Define navigation items in `src/config/navigation.ts`.\n7. Use `useAuthorization` hook for role-based access control.\n8. Handle form submissions using Ant Design's `Form` component.\n9. Use `message` component from Ant Design for user feedback.\n10. Define Redux slices using `createSlice` from Redux Toolkit.\n11. Use `persistStore` for Redux state persistence.\n12. Use `useDispatch` and `useSelector` for Redux state management.\n\n## Domain-Specific Features\n\n### Parcel Management\n\n- **Purpose**: Manage parcel tracking and status updates.\n- **Key Components**: `Parcels` page, `TableRenderer` component, `useTable` hook.\n- **Special Patterns**: Use of `useTable` hook for pagination and data fetching.\n\n## Debugging & Development Tools\n\n### DevTools Integration\n\n- **Redux DevTools**: Not explicitly mentioned, but can be integrated for state debugging.\n- **React DevTools**: Can be used for component inspection.\n\n### Logging Patterns\n\nLogging is done using `console.error` for error tracking, as seen in `src/pages/NotFound.tsx`.\n\n### Source Maps\n\nSource maps are not explicitly mentioned in the DNA snapshot.\n\n## Migration Notes\n\nNo ongoing migrations are detected in the DNA snapshot.\n\n## Best Practices\n\n1. Use design tokens for consistent theming.\n2. Avoid using hex colors directly; use design tokens instead.\n3. Ensure all pages are wrapped with `Authorize` where necessary.\n4. Use Ant Design components for form handling.\n5. Keep API service logic encapsulated in service modules.\n6. Use `useCallback` and `useEffect` hooks for performance optimization.\n7. Ensure all components are styled using Emotion.\n8. Use TypeScript interfaces for type safety.\n9. Maintain a consistent import order across files.\n10. Use `message` component for consistent user feedback.\n\nRemember: The RedX Admin Hub is designed to streamline administrative tasks for the RedX logistics platform, ensuring efficient parcel management and user access control."
    }
  }
}