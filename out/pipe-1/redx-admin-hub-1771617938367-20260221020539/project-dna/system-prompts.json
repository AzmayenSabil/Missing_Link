{
  "generatedAt": "2026-02-20T20:07:01.670Z",
  "model": "gpt-4o-2024-08-06",
  "projectId": "redx-admin-hub-1771617938367-20260221020539",
  "prompts": {
    "prd_analysis": {
      "purpose": "PRD Analysis",
      "systemPrompt": "# GitHub Copilot Instructions for RedX Admin Hub\n\n---\n\n## applyTo: '**'\n\nThis file serves as the authoritative guide for AI coding assistants working on the RedX Admin Hub project. It provides comprehensive instructions on the project's architecture, code style, state management, component patterns, API integration, and more. AI coding assistants should use this document to ensure that any code generated is consistent with the project's established conventions and patterns.\n\n## Project Overview\n\nThe RedX Admin Hub is a web application designed for administrative users of the RedX platform. Its primary purpose is to manage and oversee various operational aspects of the RedX service, including parcel tracking and user authentication. The application is built using React and TypeScript, with a focus on providing a responsive and user-friendly interface. The primary users are administrative staff who require access to detailed operational data and management tools. The project operates within the logistics and delivery business domain, supporting functionalities such as parcel management and user authentication.\n\n## Architecture & Technology Stack\n\n### Core Technologies\n\n- **React**: A JavaScript library for building user interfaces.\n- **TypeScript**: A typed superset of JavaScript that compiles to plain JavaScript.\n- **Ant Design**: A UI library for building rich user interfaces.\n- **Emotion**: A library for writing CSS styles with JavaScript.\n- **Redux Toolkit**: A library for managing application state.\n- **Axios**: A promise-based HTTP client for the browser and Node.js.\n\n### Project Structure\n\n```plaintext\n.\n├── .gitignore\n├── bun.lockb\n├── components.json\n├── eslint.config.js\n├── index.html\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── README.md\n├── tailwind.config.ts\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.node.json\n├── vite.config.ts\n├── vitest.config.ts\n├── public\n│   ├── favicon.ico\n│   ├── placeholder.svg\n│   └── robots.txt\n└── src\n    ├── assets\n    │   └── globalStyles.ts\n    ├── components\n    │   ├── authorize\n    │   │   └── Authorize.tsx\n    │   ├── layout\n    │   │   └── AppLayout.tsx\n    │   ├── table\n    │   │   └── TableRenderer.tsx\n    │   └── ui\n    │       ├── accordion.tsx\n    │       ├── alert-dialog.tsx\n    │       ├── alert.tsx\n    │       ├── aspect-ratio.tsx\n    │       ├── avatar.tsx\n    │       ├── badge.tsx\n    │       ├── breadcrumb.tsx\n    │       ├── button.tsx\n    │       ├── calendar.tsx\n    │       ├── card.tsx\n    │       ├── carousel.tsx\n    │       ├── chart.tsx\n    │       ├── checkbox.tsx\n    │       ├── collapsible.tsx\n    │       ├── command.tsx\n    │       ├── context-menu.tsx\n    │       ├── dialog.tsx\n    │       ├── drawer.tsx\n    │       ├── dropdown-menu.tsx\n    │       ├── form.tsx\n    │       ├── hover-card.tsx\n    │       ├── input-otp.tsx\n    │       ├── input.tsx\n    │       ├── label.tsx\n    │       ├── menubar.tsx\n    │       ├── navigation-menu.tsx\n    │       ├── pagination.tsx\n    │       ├── popover.tsx\n    │       ├── progress.tsx\n    │       ├── radio-group.tsx\n    │       ├── resizable.tsx\n    │       ├── scroll-area.tsx\n    │       ├── select.tsx\n    │       ├── separator.tsx\n    │       ├── sheet.tsx\n    │       ├── sidebar.tsx\n    │       ├── skeleton.tsx\n    │       ├── slider.tsx\n    │       ├── sonner.tsx\n    │       ├── switch.tsx\n    │       ├── table.tsx\n    │       ├── tabs.tsx\n    │       ├── textarea.tsx\n    │       ├── toast.tsx\n    │       ├── toaster.tsx\n    │       ├── toggle-group.tsx\n    │       ├── toggle.tsx\n    │       └── tooltip.tsx\n    ├── config\n    │   ├── getPagePermissions.ts\n    │   ├── local.ts\n    │   └── navigation.ts\n    ├── hooks\n    │   ├── use-mobile.tsx\n    │   ├── use-toast.ts\n    │   ├── useAuthorization.ts\n    │   └── useTable.ts\n    ├── lib\n    │   ├── formHelpers.ts\n    │   └── utils.ts\n    ├── pages\n    │   ├── Index.tsx\n    │   ├── Login.tsx\n    │   ├── NotFound.tsx\n    │   └── Parcels.tsx\n    ├── redux\n    │   ├── slices\n    │   │   └── AuthSlice.ts\n    │   └── store.ts\n    ├── services\n    │   ├── authAPI.ts\n    │   ├── axios.config.ts\n    │   └── parcelAPI.ts\n    ├── test\n    │   ├── example.test.ts\n    │   └── setup.ts\n    ├── types\n    │   ├── auth.ts\n    │   └── parcel.ts\n    ├── App.css\n    ├── App.tsx\n    ├── index.css\n    ├── main.tsx\n    └── vite-env.d.ts\n```\n\n## Code Style & Standards\n\n### Formatting & Linting\n\nThe project does not have Prettier or ESLint configurations present, and there is no commitlint configuration. However, the TypeScript configuration is set up with the following options:\n\n```json\n{\n  \"strict\": false,\n  \"jsx\": null,\n  \"baseUrl\": \".\",\n  \"pathAliases\": {\n    \"@/*\": [\n      \"./src/*\"\n    ]\n  }\n}\n```\n\n### Import Organization\n\nThe preferred import order is as follows: framework → UI library → third-party → local hooks → redux/state → services → constants → types. Here is an annotated example:\n\n```typescript\n// Framework imports\nimport React, { useState, useCallback } from 'react';\n\n// UI library imports\nimport { Input, Select, Button } from 'antd';\nimport { SearchOutlined } from '@ant-design/icons';\n\n// Third-party imports\nimport { css } from '@emotion/react';\n\n// Local hooks\nimport { useTable } from '@/hooks/useTable';\n\n// Redux/state imports\nimport { setUser } from '@/redux/slices/AuthSlice';\n\n// Services\nimport { fetchParcels } from '@/services/parcelAPI';\n\n// Constants\nimport { ParcelStatus } from '@/types/parcel';\n\n// Types\nimport type { ColumnsType } from 'antd/es/table';\n```\n\n## State Management\n\n### Redux Toolkit\n\nThe project uses Redux Toolkit for state management. The configuration and setup are as follows:\n\n#### Store Configuration\n\n```typescript\nimport { configureStore } from '@reduxjs/toolkit';\nimport { persistStore } from 'redux-persist';\nimport persistedReducer from './reducers';\n\nexport const store = configureStore({\n  reducer: persistedReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [\n          'persist/PERSIST',\n          'persist/REHYDRATE',\n          'persist/PAUSE',\n          'persist/PURGE',\n          'persist/REGISTER',\n        ],\n      },\n    }),\n});\n\nexport const persistor = persistStore(store);\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n```\n\n#### Auth Slice Example\n\n```typescript\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { AuthState, User } from '@/types/auth';\n\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    setUser(state, action: PayloadAction<User>) {\n      state.user = action.payload;\n      state.isAuthenticated = true;\n    },\n    clearAuth(state) {\n      state.user = null;\n      state.isAuthenticated = false;\n    },\n  },\n});\n\nexport const { setUser, clearAuth } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\n### Typed Hooks\n\nTyped hooks such as `useAppDispatch` and `useAppSelector` are not used in this project. Instead, direct usage of `useDispatch` and `useSelector` is observed.\n\n## Component Patterns\n\n### Page Structure with Authorization\n\nThe `Parcels` page demonstrates the use of authorization components:\n\n```typescript\n/** @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\nimport { useState, useCallback } from 'react';\nimport {\n  Input,\n  Select,\n  Button,\n  Tag,\n  Space,\n  Modal,\n  Typography,\n  message,\n} from 'antd';\nimport { SearchOutlined, ReloadOutlined } from '@ant-design/icons';\nimport type { ColumnsType } from 'antd/es/table';\nimport Authorize from '@/components/authorize/Authorize';\nimport AppLayout from '@/components/layout/AppLayout';\nimport TableRenderer from '@/components/table/TableRenderer';\nimport { useTable } from '@/hooks/useTable';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel, FetchParcelsParams } from '@/types/parcel';\n\nconst { Title, Text } = Typography;\n\nconst searchBarStyle = css`\n  display: flex;\n  gap: 12px;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n  align-items: flex-end;\n```\n\n### Permission-Based Conditional Rendering\n\nThe `useAuthorization` hook is used for permission-based rendering:\n\n```typescript\nexport const useAuthorization = ({\n  roles,\n}: UseAuthorizationProps): {\n  isAuthorized: boolean;\n  isAuthenticated: boolean;\n} => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) =>\n    userRoleNames.includes(role),\n  );\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n### Primary Form Handling Pattern\n\nThe project uses Ant Design's `Form` component for form handling:\n\n```typescript\nimport { Form, Input, Button, message } from 'antd';\nimport { useDispatch } from 'react-redux';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { requestLoginOtp, verifyOtp } from '@/services/authAPI';\n\nconst Login = () => {\n  const [loading, setLoading] = useState(false);\n  const [otpSent, setOtpSent] = useState(false);\n  const [form] = Form.useForm();\n  const dispatch = useDispatch();\n\n  const handleSendOtp = async () => {\n    try {\n      const phone = form.getFieldValue('phone');\n      if (!phone) {\n        message.error('Please enter phone number');\n        return;\n      }\n      setLoading(true);\n      await requestLoginOtp({ phone });\n      message.success('OTP sent successfully!');\n      setOtpSent(true);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleLogin = async () => {\n    try {\n      const values = await form.validateFields();\n      setLoading(true);\n      const res = await verifyOtp({\n        phone: values.phone,\n        otp: values.otp,\n      });\n      if (res.success && res.user) {\n        dispatch(setUser(res.user));\n        message.success('Login successful!');\n      } else {\n        message.error(res.error || 'Login failed');\n      }\n    } catch {\n      // validation error\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\" size=\"large\">\n      <Form.Item\n        name=\"phone\"\n        label=\"Phone Number\"\n        rules={[{ required: true, message: 'Phone is required' }]}\n      >\n        <Input placeholder=\"01XXXXXXXXX\" />\n      </Form.Item>\n      <Form.Item\n        name=\"otp\"\n        label=\"OTP\"\n        rules={[{ required: true, message: 'OTP is required' }]}\n      >\n        <Input />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSendOtp} loading={loading}>\n        Send OTP\n      </Button>\n      <Button type=\"primary\" onClick={handleLogin} loading={loading}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n```\n\n### Table/Data-Grid Pattern\n\nThe `useTable` hook is used for managing table data:\n\n```typescript\nimport { useState, useEffect, useCallback } from 'react';\n\ninterface UseTableParams {\n  limit: number;\n  offset: number;\n}\n\ninterface UseTableOptions<T, P extends UseTableParams> {\n  initialParams: P;\n  fetchFn: (params: P) => Promise<{ results: T[]; count: number }>;\n}\n\nexport const useTable = <T, P extends UseTableParams>({\n  initialParams,\n  fetchFn,\n}: UseTableOptions<T, P>) => {\n  const [params, setParams] = useState<P>(initialParams);\n  const [data, setData] = useState<T[]>([]);\n  const [total, setTotal] = useState(0);\n  const [loading, setLoading] = useState(false);\n\n  const fetchData = useCallback(async () => {\n    setLoading(true);\n    try {\n      const res = await fetchFn(params);\n      setData(res.results);\n      setTotal(res.count);\n    } finally {\n      setLoading(false);\n    }\n  }, [params, fetchFn]);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  const onPaginationChange = (page: number, pageSize: number) => {\n    setParams((prev) => ({\n      ...prev,\n      offset: (page - 1) * pageSize,\n      limit: pageSize,\n    }));\n  };\n\n  const onSearch = (searchParams: Partial<P>) => {\n    setParams((prev) => ({\n      ...prev,\n      ...searchParams,\n      offset: 0,\n    }));\n  };\n\n  const onReset = () => {\n    setParams(initialParams);\n  };\n\n  const updateRow = (\n    predicate: (item: T) => boolean,\n    updater: (item: T) => T,\n  ) => {\n    setData((prev) =>\n      prev.map((item) => (predicate(item) ? updater(item) : item)),\n    );\n  };\n\n  return {\n    data,\n    total,\n    loading,\n    params,\n    onPaginationChange,\n    onSearch,\n    onReset,\n    updateRow,\n  };\n};\n```\n\n### Styling Approach\n\nThe project uses Emotion for styling, as demonstrated in the `globalStyles.ts` file:\n\n```typescript\nimport { css } from '@emotion/react';\n\nexport const globalStyles = css`\n  body {\n    margin: 0;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI',\n      Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: #f5f5f5;\n  }\n\n  #root {\n    min-height: 100vh;\n  }\n`;\n```\n\n## API Integration\n\n### HTTP Client Configuration\n\nThe project uses Axios for HTTP requests. The configuration is as follows:\n\n```typescript\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n  baseURL: 'https://dummy-api.redx.local',\n  timeout: 5000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nexport default apiClient;\n```\n\n### Service Layer Pattern\n\nThe canonical service module shape is demonstrated in the `authAPI.ts` file:\n\n```typescript\nexport const requestLoginOtp = async (\n  _data: OtpRequest,\n): Promise<{ success: boolean }> => {\n  await new Promise((r) => setTimeout(r, 500));\n  return { success: true };\n};\n\nexport const verifyOtp = async (\n  data: LoginPayload,\n): Promise<{ success: boolean; user?: User; error?: string }> => {\n  await new Promise((r) => setTimeout(r, 500));\n  if (data.otp === '123456') {\n    return {\n      success: true,\n      user: {\n        phone: data.phone,\n        roles: [{ name: 'RedX Super Admin' }],\n      },\n    };\n  }\n  return { success: false, error: 'Invalid OTP' };\n};\n```\n\n### Error Handling\n\nThe project uses Ant Design's `message` component for user feedback in error handling:\n\n```typescript\ntry {\n  const values = await form.validateFields();\n  setLoading(true);\n  const res = await verifyOtp({\n    phone: values.phone,\n    otp: values.otp,\n  });\n  if (res.success && res.user) {\n    dispatch(setUser(res.user));\n    message.success('Login successful!');\n  } else {\n    message.error(res.error || 'Login failed');\n  }\n} catch {\n  message.error('Validation error');\n} finally {\n  setLoading(false);\n}\n```\n\n## Navigation & Routing\n\nThe project uses React Router for navigation and routing. The configuration is as follows:\n\n```typescript\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport Login from './pages/Login';\nimport Parcels from './pages/Parcels';\nimport NotFound from './pages/NotFound';\n\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<Navigate to=\"/parcels\" replace />} />\n      <Route path=\"/login\" element={<Login />} />\n      <Route path=\"/parcels\" element={<Parcels />} />\n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  </BrowserRouter>\n);\n```\n\n### Menu/Navigation Configuration\n\nThe navigation configuration is defined in `navigation.ts`:\n\n```typescript\nexport interface NavItem {\n  key: string;\n  label: string;\n  path: string;\n  roles: string[];\n}\n\nexport const navigationItems: NavItem[] = [\n  {\n    key: 'parcels',\n    label: 'Parcels',\n    path: '/parcels',\n    roles: ['RedX Super Admin', 'RedX Finance Team'],\n  },\n];\n```\n\n## Authentication & Authorization\n\n### Authentication Flow\n\nThe authentication flow involves sending an OTP to the user's phone and verifying it:\n\n1. User enters their phone number.\n2. An OTP is sent to the phone number.\n3. User enters the OTP.\n4. The OTP is verified, and the user is authenticated.\n\n### Hook-Based Authorization\n\nThe `useAuthorization` hook is used to check user roles and permissions:\n\n```typescript\nexport const useAuthorization = ({\n  roles,\n}: UseAuthorizationProps): {\n  isAuthorized: boolean;\n  isAuthenticated: boolean;\n} => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) =>\n    userRoleNames.includes(role),\n  );\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n## Common Utilities\n\n### Form Helpers\n\nThe `formHelpers.ts` file contains utility functions for form handling:\n\n```typescript\nexport const handleNumericValueChange = (\n  value: string,\n): string => {\n  return value.replace(/[^0-9]/g, '');\n};\n\nexport const disableFutureDates = (current: Dayjs): boolean => {\n  return current && current.valueOf() > Date.now();\n};\n```\n\n### Utility Functions\n\nThe `utils.ts` file contains utility functions for class name merging:\n\n```typescript\nimport { twMerge } from 'tailwind-merge';\nimport clsx from 'clsx';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n```\n\n## Testing & Quality\n\n### Testing Framework\n\nThe project uses Vitest for testing, with the configuration defined in `vitest.config.ts`:\n\n```typescript\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: ['./src/test/setup.ts'],\n    include: ['src/**/*.{test,spec}.{ts,tsx}'],\n  },\n  resolve: {\n    alias: { '@': path.resolve(__dirname, './src') },\n  },\n});\n```\n\n### Test-ID Conventions\n\nThe project uses `data-testid` attributes for testing, as seen in the `Login.tsx` file:\n\n```typescript\n<Form.Item\n  name=\"phone\"\n  label=\"Phone Number\"\n  rules={[{ required: true, message: 'Phone is required' }]}\n>\n  <Input data-testid=\"phone-input\" placeholder=\"01XXXXXXXXX\" />\n</Form.Item>\n```\n\n## Environment Variables\n\nThe project does not specify any required environment variables in the provided data.\n\n## Development Workflow\n\n### Local Development\n\nTo set up the project locally, use the following commands:\n\n```bash\n# Install dependencies\nnpm install\n\n# Start the development server\nnpm run dev\n\n# Build the project\nnpm run build\n\n# Start the production server\nnpm start\n```\n\n### Local Setup Requirements\n\n- Node.js version: 14.x or higher\n- Package manager: npm\n- External services: None specified\n\n### Git Workflow\n\nThe project does not specify a conventional commits format, branch naming convention, or CI/CD pipeline details.\n\n## Performance Considerations\n\nThe project does not specify any code splitting strategy, lazy loading, tree-shaking setup, or bundle analysis tools.\n\n## Common Patterns to Follow\n\n1. Use Emotion for styling components.\n2. Use Ant Design components for consistent UI patterns.\n3. Wrap route content with `Authorize` where access control is required.\n4. Use `useTable` hook for managing table data.\n5. Use `useAuthorization` hook for permission-based rendering.\n6. Use `axios` for HTTP requests with a centralized configuration.\n7. Use Redux Toolkit for state management.\n8. Use `data-testid` attributes for testing.\n9. Use `Form` component from Ant Design for form handling.\n10. Use `message` component from Ant Design for user feedback.\n11. Use `useDispatch` and `useSelector` for accessing Redux state.\n12. Use TypeScript for type safety and improved developer experience.\n\n## Domain-Specific Features\n\n### Parcel Management\n\n- **Purpose**: Manage and track parcels within the RedX platform.\n- **Key Components**: `Parcels.tsx`, `TableRenderer.tsx`\n- **Special Patterns**: Use of `useTable` hook for data management and `Authorize` component for access control.\n\n### User Authentication\n\n- **Purpose**: Authenticate users via OTP.\n- **Key Components**: `Login.tsx`, `authAPI.ts`\n- **Special Patterns**: OTP-based authentication flow with Redux state management.\n\n## Debugging & Development Tools\n\nThe project does not specify any DevTools integration or logging patterns.\n\n## Migration Notes\n\nNo ongoing migrations are detected in the project.\n\n## Best Practices\n\n1. Use design tokens for consistent theming.\n2. Avoid direct use of hex colors; use design tokens instead.\n3. Use `useCallback` and `useMemo` for performance optimization.\n4. Keep components small and focused on a single responsibility.\n5. Use TypeScript interfaces and types for defining data structures.\n6. Use `async/await` for handling asynchronous operations.\n7. Use `try/catch` blocks for error handling in asynchronous functions.\n8. Use `useEffect` for side effects in functional components.\n9. Use `useState` for managing local component state.\n10. Use `useReducer` for complex state management scenarios.\n\nRemember: The RedX Admin Hub is designed to streamline administrative tasks and enhance operational efficiency within the RedX platform."
    },
    "architecture_planning": {
      "purpose": "Architecture Planning",
      "systemPrompt": "# GitHub Copilot Instructions for RedX Admin Hub\n\n---\n\n## applyTo: '**'\n\nThis file serves as the authoritative guide for AI coding assistants working on the RedX Admin Hub project. It provides comprehensive instructions on the project's architecture, code style, state management, component patterns, API integration, and more. AI coding assistants should use this document to ensure that any code generated is consistent with the project's established conventions and patterns.\n\n## Project Overview\n\nThe RedX Admin Hub is a web application designed for administrative users of the RedX platform. Its primary purpose is to manage and oversee various operational aspects of the RedX service, including parcel tracking and user authentication. The application is built using React and TypeScript, with a focus on providing a responsive and user-friendly interface. The primary users are administrative staff who require access to detailed operational data and management tools. The project operates within the logistics and delivery business domain, supporting functionalities such as parcel management and user authentication.\n\n## Architecture & Technology Stack\n\n### Core Technologies\n\n- **React**: A JavaScript library for building user interfaces.\n- **TypeScript**: A typed superset of JavaScript that compiles to plain JavaScript.\n- **Ant Design**: A UI library for building rich user interfaces.\n- **Emotion**: A library for writing CSS styles with JavaScript.\n- **Redux Toolkit**: A library for managing application state.\n- **Axios**: A promise-based HTTP client for the browser and Node.js.\n\n### Project Structure\n\n```plaintext\n.\n├── .gitignore\n├── bun.lockb\n├── components.json\n├── eslint.config.js\n├── index.html\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── README.md\n├── tailwind.config.ts\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.node.json\n├── vite.config.ts\n├── vitest.config.ts\n├── public\n│   ├── favicon.ico\n│   ├── placeholder.svg\n│   └── robots.txt\n└── src\n    ├── assets\n    │   └── globalStyles.ts\n    ├── components\n    │   ├── authorize\n    │   │   └── Authorize.tsx\n    │   ├── layout\n    │   │   └── AppLayout.tsx\n    │   ├── table\n    │   │   └── TableRenderer.tsx\n    │   └── ui\n    │       ├── accordion.tsx\n    │       ├── alert-dialog.tsx\n    │       ├── alert.tsx\n    │       ├── aspect-ratio.tsx\n    │       ├── avatar.tsx\n    │       ├── badge.tsx\n    │       ├── breadcrumb.tsx\n    │       ├── button.tsx\n    │       ├── calendar.tsx\n    │       ├── card.tsx\n    │       ├── carousel.tsx\n    │       ├── chart.tsx\n    │       ├── checkbox.tsx\n    │       ├── collapsible.tsx\n    │       ├── command.tsx\n    │       ├── context-menu.tsx\n    │       ├── dialog.tsx\n    │       ├── drawer.tsx\n    │       ├── dropdown-menu.tsx\n    │       ├── form.tsx\n    │       ├── hover-card.tsx\n    │       ├── input-otp.tsx\n    │       ├── input.tsx\n    │       ├── label.tsx\n    │       ├── menubar.tsx\n    │       ├── navigation-menu.tsx\n    │       ├── pagination.tsx\n    │       ├── popover.tsx\n    │       ├── progress.tsx\n    │       ├── radio-group.tsx\n    │       ├── resizable.tsx\n    │       ├── scroll-area.tsx\n    │       ├── select.tsx\n    │       ├── separator.tsx\n    │       ├── sheet.tsx\n    │       ├── sidebar.tsx\n    │       ├── skeleton.tsx\n    │       ├── slider.tsx\n    │       ├── sonner.tsx\n    │       ├── switch.tsx\n    │       ├── table.tsx\n    │       ├── tabs.tsx\n    │       ├── textarea.tsx\n    │       ├── toast.tsx\n    │       ├── toaster.tsx\n    │       ├── toggle-group.tsx\n    │       ├── toggle.tsx\n    │       └── tooltip.tsx\n    ├── config\n    │   ├── getPagePermissions.ts\n    │   ├── local.ts\n    │   └── navigation.ts\n    ├── hooks\n    │   ├── use-mobile.tsx\n    │   ├── use-toast.ts\n    │   ├── useAuthorization.ts\n    │   └── useTable.ts\n    ├── lib\n    │   ├── formHelpers.ts\n    │   └── utils.ts\n    ├── pages\n    │   ├── Index.tsx\n    │   ├── Login.tsx\n    │   ├── NotFound.tsx\n    │   └── Parcels.tsx\n    ├── redux\n    │   ├── slices\n    │   │   └── AuthSlice.ts\n    │   └── store.ts\n    ├── services\n    │   ├── authAPI.ts\n    │   ├── axios.config.ts\n    │   └── parcelAPI.ts\n    ├── test\n    │   ├── example.test.ts\n    │   └── setup.ts\n    ├── types\n    │   ├── auth.ts\n    │   └── parcel.ts\n    ├── App.css\n    ├── App.tsx\n    ├── index.css\n    ├── main.tsx\n    └── vite-env.d.ts\n```\n\n## Code Style & Standards\n\n### Formatting & Linting\n\nThe project does not have Prettier or ESLint configurations present, and there is no commitlint configuration. However, the TypeScript configuration is set up with the following options:\n\n```json\n{\n  \"strict\": false,\n  \"jsx\": null,\n  \"baseUrl\": \".\",\n  \"pathAliases\": {\n    \"@/*\": [\n      \"./src/*\"\n    ]\n  }\n}\n```\n\n### Import Organization\n\nThe preferred import order is as follows: framework → UI library → third-party → local hooks → redux/state → services → constants → types. Here is an annotated example:\n\n```typescript\n// Framework imports\nimport React, { useState, useCallback } from 'react';\n\n// UI library imports\nimport { Input, Select, Button } from 'antd';\nimport { SearchOutlined } from '@ant-design/icons';\n\n// Third-party imports\nimport { css } from '@emotion/react';\n\n// Local hooks\nimport { useTable } from '@/hooks/useTable';\n\n// Redux/state imports\nimport { setUser } from '@/redux/slices/AuthSlice';\n\n// Services\nimport { fetchParcels } from '@/services/parcelAPI';\n\n// Constants\nimport { ParcelStatus } from '@/types/parcel';\n\n// Types\nimport type { ColumnsType } from 'antd/es/table';\n```\n\n## State Management\n\n### Redux Toolkit\n\nThe project uses Redux Toolkit for state management. The configuration and setup are as follows:\n\n#### Store Configuration\n\n```typescript\nimport { configureStore } from '@reduxjs/toolkit';\nimport { persistStore } from 'redux-persist';\nimport persistedReducer from './reducers';\n\nexport const store = configureStore({\n  reducer: persistedReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [\n          'persist/PERSIST',\n          'persist/REHYDRATE',\n          'persist/PAUSE',\n          'persist/PURGE',\n          'persist/REGISTER',\n        ],\n      },\n    }),\n});\n\nexport const persistor = persistStore(store);\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n```\n\n#### Auth Slice Example\n\n```typescript\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { AuthState, User } from '@/types/auth';\n\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    setUser(state, action: PayloadAction<User>) {\n      state.user = action.payload;\n      state.isAuthenticated = true;\n    },\n    clearAuth(state) {\n      state.user = null;\n      state.isAuthenticated = false;\n    },\n  },\n});\n\nexport const { setUser, clearAuth } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\n### Typed Hooks\n\nTyped hooks such as `useAppDispatch` and `useAppSelector` are not used in this project. Instead, direct usage of `useDispatch` and `useSelector` is observed.\n\n## Component Patterns\n\n### Page Structure with Authorization\n\nThe `Parcels` page demonstrates the use of authorization components:\n\n```typescript\n/** @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\nimport { useState, useCallback } from 'react';\nimport {\n  Input,\n  Select,\n  Button,\n  Tag,\n  Space,\n  Modal,\n  Typography,\n  message,\n} from 'antd';\nimport { SearchOutlined, ReloadOutlined } from '@ant-design/icons';\nimport type { ColumnsType } from 'antd/es/table';\nimport Authorize from '@/components/authorize/Authorize';\nimport AppLayout from '@/components/layout/AppLayout';\nimport TableRenderer from '@/components/table/TableRenderer';\nimport { useTable } from '@/hooks/useTable';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel, FetchParcelsParams } from '@/types/parcel';\n\nconst { Title, Text } = Typography;\n\nconst searchBarStyle = css`\n  display: flex;\n  gap: 12px;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n  align-items: flex-end;\n```\n\n### Permission-Based Conditional Rendering\n\nThe `useAuthorization` hook is used for permission-based rendering:\n\n```typescript\nexport const useAuthorization = ({\n  roles,\n}: UseAuthorizationProps): {\n  isAuthorized: boolean;\n  isAuthenticated: boolean;\n} => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) =>\n    userRoleNames.includes(role),\n  );\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n### Primary Form Handling Pattern\n\nThe project uses Ant Design's `Form` component for form handling:\n\n```typescript\nimport { Form, Input, Button, message } from 'antd';\nimport { useDispatch } from 'react-redux';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { requestLoginOtp, verifyOtp } from '@/services/authAPI';\n\nconst Login = () => {\n  const [loading, setLoading] = useState(false);\n  const [otpSent, setOtpSent] = useState(false);\n  const [form] = Form.useForm();\n  const dispatch = useDispatch();\n\n  const handleSendOtp = async () => {\n    try {\n      const phone = form.getFieldValue('phone');\n      if (!phone) {\n        message.error('Please enter phone number');\n        return;\n      }\n      setLoading(true);\n      await requestLoginOtp({ phone });\n      message.success('OTP sent successfully!');\n      setOtpSent(true);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleLogin = async () => {\n    try {\n      const values = await form.validateFields();\n      setLoading(true);\n      const res = await verifyOtp({\n        phone: values.phone,\n        otp: values.otp,\n      });\n      if (res.success && res.user) {\n        dispatch(setUser(res.user));\n        message.success('Login successful!');\n      } else {\n        message.error(res.error || 'Login failed');\n      }\n    } catch {\n      // validation error\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\" size=\"large\">\n      <Form.Item\n        name=\"phone\"\n        label=\"Phone Number\"\n        rules={[{ required: true, message: 'Phone is required' }]}\n      >\n        <Input placeholder=\"01XXXXXXXXX\" />\n      </Form.Item>\n      <Form.Item\n        name=\"otp\"\n        label=\"OTP\"\n        rules={[{ required: true, message: 'OTP is required' }]}\n      >\n        <Input />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSendOtp} loading={loading}>\n        Send OTP\n      </Button>\n      <Button type=\"primary\" onClick={handleLogin} loading={loading}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n```\n\n### Table/Data-Grid Pattern\n\nThe `useTable` hook is used for managing table data:\n\n```typescript\nimport { useState, useEffect, useCallback } from 'react';\n\ninterface UseTableParams {\n  limit: number;\n  offset: number;\n}\n\ninterface UseTableOptions<T, P extends UseTableParams> {\n  initialParams: P;\n  fetchFn: (params: P) => Promise<{ results: T[]; count: number }>;\n}\n\nexport const useTable = <T, P extends UseTableParams>({\n  initialParams,\n  fetchFn,\n}: UseTableOptions<T, P>) => {\n  const [params, setParams] = useState<P>(initialParams);\n  const [data, setData] = useState<T[]>([]);\n  const [total, setTotal] = useState(0);\n  const [loading, setLoading] = useState(false);\n\n  const fetchData = useCallback(async () => {\n    setLoading(true);\n    try {\n      const res = await fetchFn(params);\n      setData(res.results);\n      setTotal(res.count);\n    } finally {\n      setLoading(false);\n    }\n  }, [params, fetchFn]);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  const onPaginationChange = (page: number, pageSize: number) => {\n    setParams((prev) => ({\n      ...prev,\n      offset: (page - 1) * pageSize,\n      limit: pageSize,\n    }));\n  };\n\n  const onSearch = (searchParams: Partial<P>) => {\n    setParams((prev) => ({\n      ...prev,\n      ...searchParams,\n      offset: 0,\n    }));\n  };\n\n  const onReset = () => {\n    setParams(initialParams);\n  };\n\n  const updateRow = (\n    predicate: (item: T) => boolean,\n    updater: (item: T) => T,\n  ) => {\n    setData((prev) =>\n      prev.map((item) => (predicate(item) ? updater(item) : item)),\n    );\n  };\n\n  return {\n    data,\n    total,\n    loading,\n    params,\n    onPaginationChange,\n    onSearch,\n    onReset,\n    updateRow,\n  };\n};\n```\n\n### Styling Approach\n\nThe project uses Emotion for styling, as demonstrated in the `globalStyles.ts` file:\n\n```typescript\nimport { css } from '@emotion/react';\n\nexport const globalStyles = css`\n  body {\n    margin: 0;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI',\n      Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: #f5f5f5;\n  }\n\n  #root {\n    min-height: 100vh;\n  }\n`;\n```\n\n## API Integration\n\n### HTTP Client Configuration\n\nThe project uses Axios for HTTP requests. The configuration is as follows:\n\n```typescript\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n  baseURL: 'https://dummy-api.redx.local',\n  timeout: 5000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nexport default apiClient;\n```\n\n### Service Layer Pattern\n\nThe canonical service module shape is demonstrated in the `authAPI.ts` file:\n\n```typescript\nexport const requestLoginOtp = async (\n  _data: OtpRequest,\n): Promise<{ success: boolean }> => {\n  await new Promise((r) => setTimeout(r, 500));\n  return { success: true };\n};\n\nexport const verifyOtp = async (\n  data: LoginPayload,\n): Promise<{ success: boolean; user?: User; error?: string }> => {\n  await new Promise((r) => setTimeout(r, 500));\n  if (data.otp === '123456') {\n    return {\n      success: true,\n      user: {\n        phone: data.phone,\n        roles: [{ name: 'RedX Super Admin' }],\n      },\n    };\n  }\n  return { success: false, error: 'Invalid OTP' };\n};\n```\n\n### Error Handling\n\nThe project uses Ant Design's `message` component for user feedback in error handling:\n\n```typescript\ntry {\n  const values = await form.validateFields();\n  setLoading(true);\n  const res = await verifyOtp({\n    phone: values.phone,\n    otp: values.otp,\n  });\n  if (res.success && res.user) {\n    dispatch(setUser(res.user));\n    message.success('Login successful!');\n  } else {\n    message.error(res.error || 'Login failed');\n  }\n} catch {\n  message.error('Validation error');\n} finally {\n  setLoading(false);\n}\n```\n\n## Navigation & Routing\n\nThe project uses React Router for navigation and routing. The configuration is as follows:\n\n```typescript\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport Login from './pages/Login';\nimport Parcels from './pages/Parcels';\nimport NotFound from './pages/NotFound';\n\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<Navigate to=\"/parcels\" replace />} />\n      <Route path=\"/login\" element={<Login />} />\n      <Route path=\"/parcels\" element={<Parcels />} />\n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  </BrowserRouter>\n);\n```\n\n### Menu/Navigation Configuration\n\nThe navigation configuration is defined in `navigation.ts`:\n\n```typescript\nexport interface NavItem {\n  key: string;\n  label: string;\n  path: string;\n  roles: string[];\n}\n\nexport const navigationItems: NavItem[] = [\n  {\n    key: 'parcels',\n    label: 'Parcels',\n    path: '/parcels',\n    roles: ['RedX Super Admin', 'RedX Finance Team'],\n  },\n];\n```\n\n## Authentication & Authorization\n\n### Authentication Flow\n\nThe authentication flow involves sending an OTP to the user's phone and verifying it:\n\n1. User enters their phone number.\n2. An OTP is sent to the phone number.\n3. User enters the OTP.\n4. The OTP is verified, and the user is authenticated.\n\n### Hook-Based Authorization\n\nThe `useAuthorization` hook is used to check user roles and permissions:\n\n```typescript\nexport const useAuthorization = ({\n  roles,\n}: UseAuthorizationProps): {\n  isAuthorized: boolean;\n  isAuthenticated: boolean;\n} => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) =>\n    userRoleNames.includes(role),\n  );\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n## Common Utilities\n\n### Form Helpers\n\nThe `formHelpers.ts` file contains utility functions for form handling:\n\n```typescript\nexport const handleNumericValueChange = (\n  value: string,\n): string => {\n  return value.replace(/[^0-9]/g, '');\n};\n\nexport const disableFutureDates = (current: Dayjs): boolean => {\n  return current && current.valueOf() > Date.now();\n};\n```\n\n### Utility Functions\n\nThe `utils.ts` file contains utility functions for class name merging:\n\n```typescript\nimport { twMerge } from 'tailwind-merge';\nimport clsx from 'clsx';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n```\n\n## Testing & Quality\n\n### Testing Framework\n\nThe project uses Vitest for testing, with the configuration defined in `vitest.config.ts`:\n\n```typescript\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: ['./src/test/setup.ts'],\n    include: ['src/**/*.{test,spec}.{ts,tsx}'],\n  },\n  resolve: {\n    alias: { '@': path.resolve(__dirname, './src') },\n  },\n});\n```\n\n### Test-ID Conventions\n\nThe project uses `data-testid` attributes for testing, as seen in the `Login.tsx` file:\n\n```typescript\n<Form.Item\n  name=\"phone\"\n  label=\"Phone Number\"\n  rules={[{ required: true, message: 'Phone is required' }]}\n>\n  <Input data-testid=\"phone-input\" placeholder=\"01XXXXXXXXX\" />\n</Form.Item>\n```\n\n## Environment Variables\n\nThe project does not specify any required environment variables in the provided data.\n\n## Development Workflow\n\n### Local Development\n\nTo set up the project locally, use the following commands:\n\n```bash\n# Install dependencies\nnpm install\n\n# Start the development server\nnpm run dev\n\n# Build the project\nnpm run build\n\n# Start the production server\nnpm start\n```\n\n### Local Setup Requirements\n\n- Node.js version: 14.x or higher\n- Package manager: npm\n- External services: None specified\n\n### Git Workflow\n\nThe project does not specify a conventional commits format, branch naming convention, or CI/CD pipeline details.\n\n## Performance Considerations\n\nThe project does not specify any code splitting strategy, lazy loading, tree-shaking setup, or bundle analysis tools.\n\n## Common Patterns to Follow\n\n1. Use Emotion for styling components.\n2. Use Ant Design components for consistent UI patterns.\n3. Wrap route content with `Authorize` where access control is required.\n4. Use `useTable` hook for managing table data.\n5. Use `useAuthorization` hook for permission-based rendering.\n6. Use `axios` for HTTP requests with a centralized configuration.\n7. Use Redux Toolkit for state management.\n8. Use `data-testid` attributes for testing.\n9. Use `Form` component from Ant Design for form handling.\n10. Use `message` component from Ant Design for user feedback.\n11. Use `useDispatch` and `useSelector` for accessing Redux state.\n12. Use TypeScript for type safety and improved developer experience.\n\n## Domain-Specific Features\n\n### Parcel Management\n\n- **Purpose**: Manage and track parcels within the RedX platform.\n- **Key Components**: `Parcels.tsx`, `TableRenderer.tsx`\n- **Special Patterns**: Use of `useTable` hook for data management and `Authorize` component for access control.\n\n### User Authentication\n\n- **Purpose**: Authenticate users via OTP.\n- **Key Components**: `Login.tsx`, `authAPI.ts`\n- **Special Patterns**: OTP-based authentication flow with Redux state management.\n\n## Debugging & Development Tools\n\nThe project does not specify any DevTools integration or logging patterns.\n\n## Migration Notes\n\nNo ongoing migrations are detected in the project.\n\n## Best Practices\n\n1. Use design tokens for consistent theming.\n2. Avoid direct use of hex colors; use design tokens instead.\n3. Use `useCallback` and `useMemo` for performance optimization.\n4. Keep components small and focused on a single responsibility.\n5. Use TypeScript interfaces and types for defining data structures.\n6. Use `async/await` for handling asynchronous operations.\n7. Use `try/catch` blocks for error handling in asynchronous functions.\n8. Use `useEffect` for side effects in functional components.\n9. Use `useState` for managing local component state.\n10. Use `useReducer` for complex state management scenarios.\n\nRemember: The RedX Admin Hub is designed to streamline administrative tasks and enhance operational efficiency within the RedX platform."
    },
    "code_generation": {
      "purpose": "Code Generation",
      "systemPrompt": "# GitHub Copilot Instructions for RedX Admin Hub\n\n---\n\n## applyTo: '**'\n\nThis file serves as the authoritative guide for AI coding assistants working on the RedX Admin Hub project. It provides comprehensive instructions on the project's architecture, code style, state management, component patterns, API integration, and more. AI coding assistants should use this document to ensure that any code generated is consistent with the project's established conventions and patterns.\n\n## Project Overview\n\nThe RedX Admin Hub is a web application designed for administrative users of the RedX platform. Its primary purpose is to manage and oversee various operational aspects of the RedX service, including parcel tracking and user authentication. The application is built using React and TypeScript, with a focus on providing a responsive and user-friendly interface. The primary users are administrative staff who require access to detailed operational data and management tools. The project operates within the logistics and delivery business domain, supporting functionalities such as parcel management and user authentication.\n\n## Architecture & Technology Stack\n\n### Core Technologies\n\n- **React**: A JavaScript library for building user interfaces.\n- **TypeScript**: A typed superset of JavaScript that compiles to plain JavaScript.\n- **Ant Design**: A UI library for building rich user interfaces.\n- **Emotion**: A library for writing CSS styles with JavaScript.\n- **Redux Toolkit**: A library for managing application state.\n- **Axios**: A promise-based HTTP client for the browser and Node.js.\n\n### Project Structure\n\n```plaintext\n.\n├── .gitignore\n├── bun.lockb\n├── components.json\n├── eslint.config.js\n├── index.html\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── README.md\n├── tailwind.config.ts\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.node.json\n├── vite.config.ts\n├── vitest.config.ts\n├── public\n│   ├── favicon.ico\n│   ├── placeholder.svg\n│   └── robots.txt\n└── src\n    ├── assets\n    │   └── globalStyles.ts\n    ├── components\n    │   ├── authorize\n    │   │   └── Authorize.tsx\n    │   ├── layout\n    │   │   └── AppLayout.tsx\n    │   ├── table\n    │   │   └── TableRenderer.tsx\n    │   └── ui\n    │       ├── accordion.tsx\n    │       ├── alert-dialog.tsx\n    │       ├── alert.tsx\n    │       ├── aspect-ratio.tsx\n    │       ├── avatar.tsx\n    │       ├── badge.tsx\n    │       ├── breadcrumb.tsx\n    │       ├── button.tsx\n    │       ├── calendar.tsx\n    │       ├── card.tsx\n    │       ├── carousel.tsx\n    │       ├── chart.tsx\n    │       ├── checkbox.tsx\n    │       ├── collapsible.tsx\n    │       ├── command.tsx\n    │       ├── context-menu.tsx\n    │       ├── dialog.tsx\n    │       ├── drawer.tsx\n    │       ├── dropdown-menu.tsx\n    │       ├── form.tsx\n    │       ├── hover-card.tsx\n    │       ├── input-otp.tsx\n    │       ├── input.tsx\n    │       ├── label.tsx\n    │       ├── menubar.tsx\n    │       ├── navigation-menu.tsx\n    │       ├── pagination.tsx\n    │       ├── popover.tsx\n    │       ├── progress.tsx\n    │       ├── radio-group.tsx\n    │       ├── resizable.tsx\n    │       ├── scroll-area.tsx\n    │       ├── select.tsx\n    │       ├── separator.tsx\n    │       ├── sheet.tsx\n    │       ├── sidebar.tsx\n    │       ├── skeleton.tsx\n    │       ├── slider.tsx\n    │       ├── sonner.tsx\n    │       ├── switch.tsx\n    │       ├── table.tsx\n    │       ├── tabs.tsx\n    │       ├── textarea.tsx\n    │       ├── toast.tsx\n    │       ├── toaster.tsx\n    │       ├── toggle-group.tsx\n    │       ├── toggle.tsx\n    │       └── tooltip.tsx\n    ├── config\n    │   ├── getPagePermissions.ts\n    │   ├── local.ts\n    │   └── navigation.ts\n    ├── hooks\n    │   ├── use-mobile.tsx\n    │   ├── use-toast.ts\n    │   ├── useAuthorization.ts\n    │   └── useTable.ts\n    ├── lib\n    │   ├── formHelpers.ts\n    │   └── utils.ts\n    ├── pages\n    │   ├── Index.tsx\n    │   ├── Login.tsx\n    │   ├── NotFound.tsx\n    │   └── Parcels.tsx\n    ├── redux\n    │   ├── slices\n    │   │   └── AuthSlice.ts\n    │   └── store.ts\n    ├── services\n    │   ├── authAPI.ts\n    │   ├── axios.config.ts\n    │   └── parcelAPI.ts\n    ├── test\n    │   ├── example.test.ts\n    │   └── setup.ts\n    ├── types\n    │   ├── auth.ts\n    │   └── parcel.ts\n    ├── App.css\n    ├── App.tsx\n    ├── index.css\n    ├── main.tsx\n    └── vite-env.d.ts\n```\n\n## Code Style & Standards\n\n### Formatting & Linting\n\nThe project does not have Prettier or ESLint configurations present, and there is no commitlint configuration. However, the TypeScript configuration is set up with the following options:\n\n```json\n{\n  \"strict\": false,\n  \"jsx\": null,\n  \"baseUrl\": \".\",\n  \"pathAliases\": {\n    \"@/*\": [\n      \"./src/*\"\n    ]\n  }\n}\n```\n\n### Import Organization\n\nThe preferred import order is as follows: framework → UI library → third-party → local hooks → redux/state → services → constants → types. Here is an annotated example:\n\n```typescript\n// Framework imports\nimport React, { useState, useCallback } from 'react';\n\n// UI library imports\nimport { Input, Select, Button } from 'antd';\nimport { SearchOutlined } from '@ant-design/icons';\n\n// Third-party imports\nimport { css } from '@emotion/react';\n\n// Local hooks\nimport { useTable } from '@/hooks/useTable';\n\n// Redux/state imports\nimport { setUser } from '@/redux/slices/AuthSlice';\n\n// Services\nimport { fetchParcels } from '@/services/parcelAPI';\n\n// Constants\nimport { ParcelStatus } from '@/types/parcel';\n\n// Types\nimport type { ColumnsType } from 'antd/es/table';\n```\n\n## State Management\n\n### Redux Toolkit\n\nThe project uses Redux Toolkit for state management. The configuration and setup are as follows:\n\n#### Store Configuration\n\n```typescript\nimport { configureStore } from '@reduxjs/toolkit';\nimport { persistStore } from 'redux-persist';\nimport persistedReducer from './reducers';\n\nexport const store = configureStore({\n  reducer: persistedReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [\n          'persist/PERSIST',\n          'persist/REHYDRATE',\n          'persist/PAUSE',\n          'persist/PURGE',\n          'persist/REGISTER',\n        ],\n      },\n    }),\n});\n\nexport const persistor = persistStore(store);\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n```\n\n#### Auth Slice Example\n\n```typescript\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { AuthState, User } from '@/types/auth';\n\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    setUser(state, action: PayloadAction<User>) {\n      state.user = action.payload;\n      state.isAuthenticated = true;\n    },\n    clearAuth(state) {\n      state.user = null;\n      state.isAuthenticated = false;\n    },\n  },\n});\n\nexport const { setUser, clearAuth } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\n### Typed Hooks\n\nTyped hooks such as `useAppDispatch` and `useAppSelector` are not used in this project. Instead, direct usage of `useDispatch` and `useSelector` is observed.\n\n## Component Patterns\n\n### Page Structure with Authorization\n\nThe `Parcels` page demonstrates the use of authorization components:\n\n```typescript\n/** @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\nimport { useState, useCallback } from 'react';\nimport {\n  Input,\n  Select,\n  Button,\n  Tag,\n  Space,\n  Modal,\n  Typography,\n  message,\n} from 'antd';\nimport { SearchOutlined, ReloadOutlined } from '@ant-design/icons';\nimport type { ColumnsType } from 'antd/es/table';\nimport Authorize from '@/components/authorize/Authorize';\nimport AppLayout from '@/components/layout/AppLayout';\nimport TableRenderer from '@/components/table/TableRenderer';\nimport { useTable } from '@/hooks/useTable';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel, FetchParcelsParams } from '@/types/parcel';\n\nconst { Title, Text } = Typography;\n\nconst searchBarStyle = css`\n  display: flex;\n  gap: 12px;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n  align-items: flex-end;\n```\n\n### Permission-Based Conditional Rendering\n\nThe `useAuthorization` hook is used for permission-based rendering:\n\n```typescript\nexport const useAuthorization = ({\n  roles,\n}: UseAuthorizationProps): {\n  isAuthorized: boolean;\n  isAuthenticated: boolean;\n} => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) =>\n    userRoleNames.includes(role),\n  );\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n### Primary Form Handling Pattern\n\nThe project uses Ant Design's `Form` component for form handling:\n\n```typescript\nimport { Form, Input, Button, message } from 'antd';\nimport { useDispatch } from 'react-redux';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { requestLoginOtp, verifyOtp } from '@/services/authAPI';\n\nconst Login = () => {\n  const [loading, setLoading] = useState(false);\n  const [otpSent, setOtpSent] = useState(false);\n  const [form] = Form.useForm();\n  const dispatch = useDispatch();\n\n  const handleSendOtp = async () => {\n    try {\n      const phone = form.getFieldValue('phone');\n      if (!phone) {\n        message.error('Please enter phone number');\n        return;\n      }\n      setLoading(true);\n      await requestLoginOtp({ phone });\n      message.success('OTP sent successfully!');\n      setOtpSent(true);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleLogin = async () => {\n    try {\n      const values = await form.validateFields();\n      setLoading(true);\n      const res = await verifyOtp({\n        phone: values.phone,\n        otp: values.otp,\n      });\n      if (res.success && res.user) {\n        dispatch(setUser(res.user));\n        message.success('Login successful!');\n      } else {\n        message.error(res.error || 'Login failed');\n      }\n    } catch {\n      // validation error\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\" size=\"large\">\n      <Form.Item\n        name=\"phone\"\n        label=\"Phone Number\"\n        rules={[{ required: true, message: 'Phone is required' }]}\n      >\n        <Input placeholder=\"01XXXXXXXXX\" />\n      </Form.Item>\n      <Form.Item\n        name=\"otp\"\n        label=\"OTP\"\n        rules={[{ required: true, message: 'OTP is required' }]}\n      >\n        <Input />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSendOtp} loading={loading}>\n        Send OTP\n      </Button>\n      <Button type=\"primary\" onClick={handleLogin} loading={loading}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n```\n\n### Table/Data-Grid Pattern\n\nThe `useTable` hook is used for managing table data:\n\n```typescript\nimport { useState, useEffect, useCallback } from 'react';\n\ninterface UseTableParams {\n  limit: number;\n  offset: number;\n}\n\ninterface UseTableOptions<T, P extends UseTableParams> {\n  initialParams: P;\n  fetchFn: (params: P) => Promise<{ results: T[]; count: number }>;\n}\n\nexport const useTable = <T, P extends UseTableParams>({\n  initialParams,\n  fetchFn,\n}: UseTableOptions<T, P>) => {\n  const [params, setParams] = useState<P>(initialParams);\n  const [data, setData] = useState<T[]>([]);\n  const [total, setTotal] = useState(0);\n  const [loading, setLoading] = useState(false);\n\n  const fetchData = useCallback(async () => {\n    setLoading(true);\n    try {\n      const res = await fetchFn(params);\n      setData(res.results);\n      setTotal(res.count);\n    } finally {\n      setLoading(false);\n    }\n  }, [params, fetchFn]);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  const onPaginationChange = (page: number, pageSize: number) => {\n    setParams((prev) => ({\n      ...prev,\n      offset: (page - 1) * pageSize,\n      limit: pageSize,\n    }));\n  };\n\n  const onSearch = (searchParams: Partial<P>) => {\n    setParams((prev) => ({\n      ...prev,\n      ...searchParams,\n      offset: 0,\n    }));\n  };\n\n  const onReset = () => {\n    setParams(initialParams);\n  };\n\n  const updateRow = (\n    predicate: (item: T) => boolean,\n    updater: (item: T) => T,\n  ) => {\n    setData((prev) =>\n      prev.map((item) => (predicate(item) ? updater(item) : item)),\n    );\n  };\n\n  return {\n    data,\n    total,\n    loading,\n    params,\n    onPaginationChange,\n    onSearch,\n    onReset,\n    updateRow,\n  };\n};\n```\n\n### Styling Approach\n\nThe project uses Emotion for styling, as demonstrated in the `globalStyles.ts` file:\n\n```typescript\nimport { css } from '@emotion/react';\n\nexport const globalStyles = css`\n  body {\n    margin: 0;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI',\n      Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: #f5f5f5;\n  }\n\n  #root {\n    min-height: 100vh;\n  }\n`;\n```\n\n## API Integration\n\n### HTTP Client Configuration\n\nThe project uses Axios for HTTP requests. The configuration is as follows:\n\n```typescript\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n  baseURL: 'https://dummy-api.redx.local',\n  timeout: 5000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nexport default apiClient;\n```\n\n### Service Layer Pattern\n\nThe canonical service module shape is demonstrated in the `authAPI.ts` file:\n\n```typescript\nexport const requestLoginOtp = async (\n  _data: OtpRequest,\n): Promise<{ success: boolean }> => {\n  await new Promise((r) => setTimeout(r, 500));\n  return { success: true };\n};\n\nexport const verifyOtp = async (\n  data: LoginPayload,\n): Promise<{ success: boolean; user?: User; error?: string }> => {\n  await new Promise((r) => setTimeout(r, 500));\n  if (data.otp === '123456') {\n    return {\n      success: true,\n      user: {\n        phone: data.phone,\n        roles: [{ name: 'RedX Super Admin' }],\n      },\n    };\n  }\n  return { success: false, error: 'Invalid OTP' };\n};\n```\n\n### Error Handling\n\nThe project uses Ant Design's `message` component for user feedback in error handling:\n\n```typescript\ntry {\n  const values = await form.validateFields();\n  setLoading(true);\n  const res = await verifyOtp({\n    phone: values.phone,\n    otp: values.otp,\n  });\n  if (res.success && res.user) {\n    dispatch(setUser(res.user));\n    message.success('Login successful!');\n  } else {\n    message.error(res.error || 'Login failed');\n  }\n} catch {\n  message.error('Validation error');\n} finally {\n  setLoading(false);\n}\n```\n\n## Navigation & Routing\n\nThe project uses React Router for navigation and routing. The configuration is as follows:\n\n```typescript\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport Login from './pages/Login';\nimport Parcels from './pages/Parcels';\nimport NotFound from './pages/NotFound';\n\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<Navigate to=\"/parcels\" replace />} />\n      <Route path=\"/login\" element={<Login />} />\n      <Route path=\"/parcels\" element={<Parcels />} />\n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  </BrowserRouter>\n);\n```\n\n### Menu/Navigation Configuration\n\nThe navigation configuration is defined in `navigation.ts`:\n\n```typescript\nexport interface NavItem {\n  key: string;\n  label: string;\n  path: string;\n  roles: string[];\n}\n\nexport const navigationItems: NavItem[] = [\n  {\n    key: 'parcels',\n    label: 'Parcels',\n    path: '/parcels',\n    roles: ['RedX Super Admin', 'RedX Finance Team'],\n  },\n];\n```\n\n## Authentication & Authorization\n\n### Authentication Flow\n\nThe authentication flow involves sending an OTP to the user's phone and verifying it:\n\n1. User enters their phone number.\n2. An OTP is sent to the phone number.\n3. User enters the OTP.\n4. The OTP is verified, and the user is authenticated.\n\n### Hook-Based Authorization\n\nThe `useAuthorization` hook is used to check user roles and permissions:\n\n```typescript\nexport const useAuthorization = ({\n  roles,\n}: UseAuthorizationProps): {\n  isAuthorized: boolean;\n  isAuthenticated: boolean;\n} => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) =>\n    userRoleNames.includes(role),\n  );\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n## Common Utilities\n\n### Form Helpers\n\nThe `formHelpers.ts` file contains utility functions for form handling:\n\n```typescript\nexport const handleNumericValueChange = (\n  value: string,\n): string => {\n  return value.replace(/[^0-9]/g, '');\n};\n\nexport const disableFutureDates = (current: Dayjs): boolean => {\n  return current && current.valueOf() > Date.now();\n};\n```\n\n### Utility Functions\n\nThe `utils.ts` file contains utility functions for class name merging:\n\n```typescript\nimport { twMerge } from 'tailwind-merge';\nimport clsx from 'clsx';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n```\n\n## Testing & Quality\n\n### Testing Framework\n\nThe project uses Vitest for testing, with the configuration defined in `vitest.config.ts`:\n\n```typescript\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: ['./src/test/setup.ts'],\n    include: ['src/**/*.{test,spec}.{ts,tsx}'],\n  },\n  resolve: {\n    alias: { '@': path.resolve(__dirname, './src') },\n  },\n});\n```\n\n### Test-ID Conventions\n\nThe project uses `data-testid` attributes for testing, as seen in the `Login.tsx` file:\n\n```typescript\n<Form.Item\n  name=\"phone\"\n  label=\"Phone Number\"\n  rules={[{ required: true, message: 'Phone is required' }]}\n>\n  <Input data-testid=\"phone-input\" placeholder=\"01XXXXXXXXX\" />\n</Form.Item>\n```\n\n## Environment Variables\n\nThe project does not specify any required environment variables in the provided data.\n\n## Development Workflow\n\n### Local Development\n\nTo set up the project locally, use the following commands:\n\n```bash\n# Install dependencies\nnpm install\n\n# Start the development server\nnpm run dev\n\n# Build the project\nnpm run build\n\n# Start the production server\nnpm start\n```\n\n### Local Setup Requirements\n\n- Node.js version: 14.x or higher\n- Package manager: npm\n- External services: None specified\n\n### Git Workflow\n\nThe project does not specify a conventional commits format, branch naming convention, or CI/CD pipeline details.\n\n## Performance Considerations\n\nThe project does not specify any code splitting strategy, lazy loading, tree-shaking setup, or bundle analysis tools.\n\n## Common Patterns to Follow\n\n1. Use Emotion for styling components.\n2. Use Ant Design components for consistent UI patterns.\n3. Wrap route content with `Authorize` where access control is required.\n4. Use `useTable` hook for managing table data.\n5. Use `useAuthorization` hook for permission-based rendering.\n6. Use `axios` for HTTP requests with a centralized configuration.\n7. Use Redux Toolkit for state management.\n8. Use `data-testid` attributes for testing.\n9. Use `Form` component from Ant Design for form handling.\n10. Use `message` component from Ant Design for user feedback.\n11. Use `useDispatch` and `useSelector` for accessing Redux state.\n12. Use TypeScript for type safety and improved developer experience.\n\n## Domain-Specific Features\n\n### Parcel Management\n\n- **Purpose**: Manage and track parcels within the RedX platform.\n- **Key Components**: `Parcels.tsx`, `TableRenderer.tsx`\n- **Special Patterns**: Use of `useTable` hook for data management and `Authorize` component for access control.\n\n### User Authentication\n\n- **Purpose**: Authenticate users via OTP.\n- **Key Components**: `Login.tsx`, `authAPI.ts`\n- **Special Patterns**: OTP-based authentication flow with Redux state management.\n\n## Debugging & Development Tools\n\nThe project does not specify any DevTools integration or logging patterns.\n\n## Migration Notes\n\nNo ongoing migrations are detected in the project.\n\n## Best Practices\n\n1. Use design tokens for consistent theming.\n2. Avoid direct use of hex colors; use design tokens instead.\n3. Use `useCallback` and `useMemo` for performance optimization.\n4. Keep components small and focused on a single responsibility.\n5. Use TypeScript interfaces and types for defining data structures.\n6. Use `async/await` for handling asynchronous operations.\n7. Use `try/catch` blocks for error handling in asynchronous functions.\n8. Use `useEffect` for side effects in functional components.\n9. Use `useState` for managing local component state.\n10. Use `useReducer` for complex state management scenarios.\n\nRemember: The RedX Admin Hub is designed to streamline administrative tasks and enhance operational efficiency within the RedX platform."
    },
    "component_creation": {
      "purpose": "Component Creation",
      "systemPrompt": "# GitHub Copilot Instructions for RedX Admin Hub\n\n---\n\n## applyTo: '**'\n\nThis file serves as the authoritative guide for AI coding assistants working on the RedX Admin Hub project. It provides comprehensive instructions on the project's architecture, code style, state management, component patterns, API integration, and more. AI coding assistants should use this document to ensure that any code generated is consistent with the project's established conventions and patterns.\n\n## Project Overview\n\nThe RedX Admin Hub is a web application designed for administrative users of the RedX platform. Its primary purpose is to manage and oversee various operational aspects of the RedX service, including parcel tracking and user authentication. The application is built using React and TypeScript, with a focus on providing a responsive and user-friendly interface. The primary users are administrative staff who require access to detailed operational data and management tools. The project operates within the logistics and delivery business domain, supporting functionalities such as parcel management and user authentication.\n\n## Architecture & Technology Stack\n\n### Core Technologies\n\n- **React**: A JavaScript library for building user interfaces.\n- **TypeScript**: A typed superset of JavaScript that compiles to plain JavaScript.\n- **Ant Design**: A UI library for building rich user interfaces.\n- **Emotion**: A library for writing CSS styles with JavaScript.\n- **Redux Toolkit**: A library for managing application state.\n- **Axios**: A promise-based HTTP client for the browser and Node.js.\n\n### Project Structure\n\n```plaintext\n.\n├── .gitignore\n├── bun.lockb\n├── components.json\n├── eslint.config.js\n├── index.html\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── README.md\n├── tailwind.config.ts\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.node.json\n├── vite.config.ts\n├── vitest.config.ts\n├── public\n│   ├── favicon.ico\n│   ├── placeholder.svg\n│   └── robots.txt\n└── src\n    ├── assets\n    │   └── globalStyles.ts\n    ├── components\n    │   ├── authorize\n    │   │   └── Authorize.tsx\n    │   ├── layout\n    │   │   └── AppLayout.tsx\n    │   ├── table\n    │   │   └── TableRenderer.tsx\n    │   └── ui\n    │       ├── accordion.tsx\n    │       ├── alert-dialog.tsx\n    │       ├── alert.tsx\n    │       ├── aspect-ratio.tsx\n    │       ├── avatar.tsx\n    │       ├── badge.tsx\n    │       ├── breadcrumb.tsx\n    │       ├── button.tsx\n    │       ├── calendar.tsx\n    │       ├── card.tsx\n    │       ├── carousel.tsx\n    │       ├── chart.tsx\n    │       ├── checkbox.tsx\n    │       ├── collapsible.tsx\n    │       ├── command.tsx\n    │       ├── context-menu.tsx\n    │       ├── dialog.tsx\n    │       ├── drawer.tsx\n    │       ├── dropdown-menu.tsx\n    │       ├── form.tsx\n    │       ├── hover-card.tsx\n    │       ├── input-otp.tsx\n    │       ├── input.tsx\n    │       ├── label.tsx\n    │       ├── menubar.tsx\n    │       ├── navigation-menu.tsx\n    │       ├── pagination.tsx\n    │       ├── popover.tsx\n    │       ├── progress.tsx\n    │       ├── radio-group.tsx\n    │       ├── resizable.tsx\n    │       ├── scroll-area.tsx\n    │       ├── select.tsx\n    │       ├── separator.tsx\n    │       ├── sheet.tsx\n    │       ├── sidebar.tsx\n    │       ├── skeleton.tsx\n    │       ├── slider.tsx\n    │       ├── sonner.tsx\n    │       ├── switch.tsx\n    │       ├── table.tsx\n    │       ├── tabs.tsx\n    │       ├── textarea.tsx\n    │       ├── toast.tsx\n    │       ├── toaster.tsx\n    │       ├── toggle-group.tsx\n    │       ├── toggle.tsx\n    │       └── tooltip.tsx\n    ├── config\n    │   ├── getPagePermissions.ts\n    │   ├── local.ts\n    │   └── navigation.ts\n    ├── hooks\n    │   ├── use-mobile.tsx\n    │   ├── use-toast.ts\n    │   ├── useAuthorization.ts\n    │   └── useTable.ts\n    ├── lib\n    │   ├── formHelpers.ts\n    │   └── utils.ts\n    ├── pages\n    │   ├── Index.tsx\n    │   ├── Login.tsx\n    │   ├── NotFound.tsx\n    │   └── Parcels.tsx\n    ├── redux\n    │   ├── slices\n    │   │   └── AuthSlice.ts\n    │   └── store.ts\n    ├── services\n    │   ├── authAPI.ts\n    │   ├── axios.config.ts\n    │   └── parcelAPI.ts\n    ├── test\n    │   ├── example.test.ts\n    │   └── setup.ts\n    ├── types\n    │   ├── auth.ts\n    │   └── parcel.ts\n    ├── App.css\n    ├── App.tsx\n    ├── index.css\n    ├── main.tsx\n    └── vite-env.d.ts\n```\n\n## Code Style & Standards\n\n### Formatting & Linting\n\nThe project does not have Prettier or ESLint configurations present, and there is no commitlint configuration. However, the TypeScript configuration is set up with the following options:\n\n```json\n{\n  \"strict\": false,\n  \"jsx\": null,\n  \"baseUrl\": \".\",\n  \"pathAliases\": {\n    \"@/*\": [\n      \"./src/*\"\n    ]\n  }\n}\n```\n\n### Import Organization\n\nThe preferred import order is as follows: framework → UI library → third-party → local hooks → redux/state → services → constants → types. Here is an annotated example:\n\n```typescript\n// Framework imports\nimport React, { useState, useCallback } from 'react';\n\n// UI library imports\nimport { Input, Select, Button } from 'antd';\nimport { SearchOutlined } from '@ant-design/icons';\n\n// Third-party imports\nimport { css } from '@emotion/react';\n\n// Local hooks\nimport { useTable } from '@/hooks/useTable';\n\n// Redux/state imports\nimport { setUser } from '@/redux/slices/AuthSlice';\n\n// Services\nimport { fetchParcels } from '@/services/parcelAPI';\n\n// Constants\nimport { ParcelStatus } from '@/types/parcel';\n\n// Types\nimport type { ColumnsType } from 'antd/es/table';\n```\n\n## State Management\n\n### Redux Toolkit\n\nThe project uses Redux Toolkit for state management. The configuration and setup are as follows:\n\n#### Store Configuration\n\n```typescript\nimport { configureStore } from '@reduxjs/toolkit';\nimport { persistStore } from 'redux-persist';\nimport persistedReducer from './reducers';\n\nexport const store = configureStore({\n  reducer: persistedReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [\n          'persist/PERSIST',\n          'persist/REHYDRATE',\n          'persist/PAUSE',\n          'persist/PURGE',\n          'persist/REGISTER',\n        ],\n      },\n    }),\n});\n\nexport const persistor = persistStore(store);\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n```\n\n#### Auth Slice Example\n\n```typescript\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { AuthState, User } from '@/types/auth';\n\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    setUser(state, action: PayloadAction<User>) {\n      state.user = action.payload;\n      state.isAuthenticated = true;\n    },\n    clearAuth(state) {\n      state.user = null;\n      state.isAuthenticated = false;\n    },\n  },\n});\n\nexport const { setUser, clearAuth } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\n### Typed Hooks\n\nTyped hooks such as `useAppDispatch` and `useAppSelector` are not used in this project. Instead, direct usage of `useDispatch` and `useSelector` is observed.\n\n## Component Patterns\n\n### Page Structure with Authorization\n\nThe `Parcels` page demonstrates the use of authorization components:\n\n```typescript\n/** @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\nimport { useState, useCallback } from 'react';\nimport {\n  Input,\n  Select,\n  Button,\n  Tag,\n  Space,\n  Modal,\n  Typography,\n  message,\n} from 'antd';\nimport { SearchOutlined, ReloadOutlined } from '@ant-design/icons';\nimport type { ColumnsType } from 'antd/es/table';\nimport Authorize from '@/components/authorize/Authorize';\nimport AppLayout from '@/components/layout/AppLayout';\nimport TableRenderer from '@/components/table/TableRenderer';\nimport { useTable } from '@/hooks/useTable';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel, FetchParcelsParams } from '@/types/parcel';\n\nconst { Title, Text } = Typography;\n\nconst searchBarStyle = css`\n  display: flex;\n  gap: 12px;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n  align-items: flex-end;\n```\n\n### Permission-Based Conditional Rendering\n\nThe `useAuthorization` hook is used for permission-based rendering:\n\n```typescript\nexport const useAuthorization = ({\n  roles,\n}: UseAuthorizationProps): {\n  isAuthorized: boolean;\n  isAuthenticated: boolean;\n} => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) =>\n    userRoleNames.includes(role),\n  );\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n### Primary Form Handling Pattern\n\nThe project uses Ant Design's `Form` component for form handling:\n\n```typescript\nimport { Form, Input, Button, message } from 'antd';\nimport { useDispatch } from 'react-redux';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { requestLoginOtp, verifyOtp } from '@/services/authAPI';\n\nconst Login = () => {\n  const [loading, setLoading] = useState(false);\n  const [otpSent, setOtpSent] = useState(false);\n  const [form] = Form.useForm();\n  const dispatch = useDispatch();\n\n  const handleSendOtp = async () => {\n    try {\n      const phone = form.getFieldValue('phone');\n      if (!phone) {\n        message.error('Please enter phone number');\n        return;\n      }\n      setLoading(true);\n      await requestLoginOtp({ phone });\n      message.success('OTP sent successfully!');\n      setOtpSent(true);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleLogin = async () => {\n    try {\n      const values = await form.validateFields();\n      setLoading(true);\n      const res = await verifyOtp({\n        phone: values.phone,\n        otp: values.otp,\n      });\n      if (res.success && res.user) {\n        dispatch(setUser(res.user));\n        message.success('Login successful!');\n      } else {\n        message.error(res.error || 'Login failed');\n      }\n    } catch {\n      // validation error\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\" size=\"large\">\n      <Form.Item\n        name=\"phone\"\n        label=\"Phone Number\"\n        rules={[{ required: true, message: 'Phone is required' }]}\n      >\n        <Input placeholder=\"01XXXXXXXXX\" />\n      </Form.Item>\n      <Form.Item\n        name=\"otp\"\n        label=\"OTP\"\n        rules={[{ required: true, message: 'OTP is required' }]}\n      >\n        <Input />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSendOtp} loading={loading}>\n        Send OTP\n      </Button>\n      <Button type=\"primary\" onClick={handleLogin} loading={loading}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n```\n\n### Table/Data-Grid Pattern\n\nThe `useTable` hook is used for managing table data:\n\n```typescript\nimport { useState, useEffect, useCallback } from 'react';\n\ninterface UseTableParams {\n  limit: number;\n  offset: number;\n}\n\ninterface UseTableOptions<T, P extends UseTableParams> {\n  initialParams: P;\n  fetchFn: (params: P) => Promise<{ results: T[]; count: number }>;\n}\n\nexport const useTable = <T, P extends UseTableParams>({\n  initialParams,\n  fetchFn,\n}: UseTableOptions<T, P>) => {\n  const [params, setParams] = useState<P>(initialParams);\n  const [data, setData] = useState<T[]>([]);\n  const [total, setTotal] = useState(0);\n  const [loading, setLoading] = useState(false);\n\n  const fetchData = useCallback(async () => {\n    setLoading(true);\n    try {\n      const res = await fetchFn(params);\n      setData(res.results);\n      setTotal(res.count);\n    } finally {\n      setLoading(false);\n    }\n  }, [params, fetchFn]);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  const onPaginationChange = (page: number, pageSize: number) => {\n    setParams((prev) => ({\n      ...prev,\n      offset: (page - 1) * pageSize,\n      limit: pageSize,\n    }));\n  };\n\n  const onSearch = (searchParams: Partial<P>) => {\n    setParams((prev) => ({\n      ...prev,\n      ...searchParams,\n      offset: 0,\n    }));\n  };\n\n  const onReset = () => {\n    setParams(initialParams);\n  };\n\n  const updateRow = (\n    predicate: (item: T) => boolean,\n    updater: (item: T) => T,\n  ) => {\n    setData((prev) =>\n      prev.map((item) => (predicate(item) ? updater(item) : item)),\n    );\n  };\n\n  return {\n    data,\n    total,\n    loading,\n    params,\n    onPaginationChange,\n    onSearch,\n    onReset,\n    updateRow,\n  };\n};\n```\n\n### Styling Approach\n\nThe project uses Emotion for styling, as demonstrated in the `globalStyles.ts` file:\n\n```typescript\nimport { css } from '@emotion/react';\n\nexport const globalStyles = css`\n  body {\n    margin: 0;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI',\n      Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: #f5f5f5;\n  }\n\n  #root {\n    min-height: 100vh;\n  }\n`;\n```\n\n## API Integration\n\n### HTTP Client Configuration\n\nThe project uses Axios for HTTP requests. The configuration is as follows:\n\n```typescript\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n  baseURL: 'https://dummy-api.redx.local',\n  timeout: 5000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nexport default apiClient;\n```\n\n### Service Layer Pattern\n\nThe canonical service module shape is demonstrated in the `authAPI.ts` file:\n\n```typescript\nexport const requestLoginOtp = async (\n  _data: OtpRequest,\n): Promise<{ success: boolean }> => {\n  await new Promise((r) => setTimeout(r, 500));\n  return { success: true };\n};\n\nexport const verifyOtp = async (\n  data: LoginPayload,\n): Promise<{ success: boolean; user?: User; error?: string }> => {\n  await new Promise((r) => setTimeout(r, 500));\n  if (data.otp === '123456') {\n    return {\n      success: true,\n      user: {\n        phone: data.phone,\n        roles: [{ name: 'RedX Super Admin' }],\n      },\n    };\n  }\n  return { success: false, error: 'Invalid OTP' };\n};\n```\n\n### Error Handling\n\nThe project uses Ant Design's `message` component for user feedback in error handling:\n\n```typescript\ntry {\n  const values = await form.validateFields();\n  setLoading(true);\n  const res = await verifyOtp({\n    phone: values.phone,\n    otp: values.otp,\n  });\n  if (res.success && res.user) {\n    dispatch(setUser(res.user));\n    message.success('Login successful!');\n  } else {\n    message.error(res.error || 'Login failed');\n  }\n} catch {\n  message.error('Validation error');\n} finally {\n  setLoading(false);\n}\n```\n\n## Navigation & Routing\n\nThe project uses React Router for navigation and routing. The configuration is as follows:\n\n```typescript\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport Login from './pages/Login';\nimport Parcels from './pages/Parcels';\nimport NotFound from './pages/NotFound';\n\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<Navigate to=\"/parcels\" replace />} />\n      <Route path=\"/login\" element={<Login />} />\n      <Route path=\"/parcels\" element={<Parcels />} />\n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  </BrowserRouter>\n);\n```\n\n### Menu/Navigation Configuration\n\nThe navigation configuration is defined in `navigation.ts`:\n\n```typescript\nexport interface NavItem {\n  key: string;\n  label: string;\n  path: string;\n  roles: string[];\n}\n\nexport const navigationItems: NavItem[] = [\n  {\n    key: 'parcels',\n    label: 'Parcels',\n    path: '/parcels',\n    roles: ['RedX Super Admin', 'RedX Finance Team'],\n  },\n];\n```\n\n## Authentication & Authorization\n\n### Authentication Flow\n\nThe authentication flow involves sending an OTP to the user's phone and verifying it:\n\n1. User enters their phone number.\n2. An OTP is sent to the phone number.\n3. User enters the OTP.\n4. The OTP is verified, and the user is authenticated.\n\n### Hook-Based Authorization\n\nThe `useAuthorization` hook is used to check user roles and permissions:\n\n```typescript\nexport const useAuthorization = ({\n  roles,\n}: UseAuthorizationProps): {\n  isAuthorized: boolean;\n  isAuthenticated: boolean;\n} => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) =>\n    userRoleNames.includes(role),\n  );\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n## Common Utilities\n\n### Form Helpers\n\nThe `formHelpers.ts` file contains utility functions for form handling:\n\n```typescript\nexport const handleNumericValueChange = (\n  value: string,\n): string => {\n  return value.replace(/[^0-9]/g, '');\n};\n\nexport const disableFutureDates = (current: Dayjs): boolean => {\n  return current && current.valueOf() > Date.now();\n};\n```\n\n### Utility Functions\n\nThe `utils.ts` file contains utility functions for class name merging:\n\n```typescript\nimport { twMerge } from 'tailwind-merge';\nimport clsx from 'clsx';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n```\n\n## Testing & Quality\n\n### Testing Framework\n\nThe project uses Vitest for testing, with the configuration defined in `vitest.config.ts`:\n\n```typescript\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: ['./src/test/setup.ts'],\n    include: ['src/**/*.{test,spec}.{ts,tsx}'],\n  },\n  resolve: {\n    alias: { '@': path.resolve(__dirname, './src') },\n  },\n});\n```\n\n### Test-ID Conventions\n\nThe project uses `data-testid` attributes for testing, as seen in the `Login.tsx` file:\n\n```typescript\n<Form.Item\n  name=\"phone\"\n  label=\"Phone Number\"\n  rules={[{ required: true, message: 'Phone is required' }]}\n>\n  <Input data-testid=\"phone-input\" placeholder=\"01XXXXXXXXX\" />\n</Form.Item>\n```\n\n## Environment Variables\n\nThe project does not specify any required environment variables in the provided data.\n\n## Development Workflow\n\n### Local Development\n\nTo set up the project locally, use the following commands:\n\n```bash\n# Install dependencies\nnpm install\n\n# Start the development server\nnpm run dev\n\n# Build the project\nnpm run build\n\n# Start the production server\nnpm start\n```\n\n### Local Setup Requirements\n\n- Node.js version: 14.x or higher\n- Package manager: npm\n- External services: None specified\n\n### Git Workflow\n\nThe project does not specify a conventional commits format, branch naming convention, or CI/CD pipeline details.\n\n## Performance Considerations\n\nThe project does not specify any code splitting strategy, lazy loading, tree-shaking setup, or bundle analysis tools.\n\n## Common Patterns to Follow\n\n1. Use Emotion for styling components.\n2. Use Ant Design components for consistent UI patterns.\n3. Wrap route content with `Authorize` where access control is required.\n4. Use `useTable` hook for managing table data.\n5. Use `useAuthorization` hook for permission-based rendering.\n6. Use `axios` for HTTP requests with a centralized configuration.\n7. Use Redux Toolkit for state management.\n8. Use `data-testid` attributes for testing.\n9. Use `Form` component from Ant Design for form handling.\n10. Use `message` component from Ant Design for user feedback.\n11. Use `useDispatch` and `useSelector` for accessing Redux state.\n12. Use TypeScript for type safety and improved developer experience.\n\n## Domain-Specific Features\n\n### Parcel Management\n\n- **Purpose**: Manage and track parcels within the RedX platform.\n- **Key Components**: `Parcels.tsx`, `TableRenderer.tsx`\n- **Special Patterns**: Use of `useTable` hook for data management and `Authorize` component for access control.\n\n### User Authentication\n\n- **Purpose**: Authenticate users via OTP.\n- **Key Components**: `Login.tsx`, `authAPI.ts`\n- **Special Patterns**: OTP-based authentication flow with Redux state management.\n\n## Debugging & Development Tools\n\nThe project does not specify any DevTools integration or logging patterns.\n\n## Migration Notes\n\nNo ongoing migrations are detected in the project.\n\n## Best Practices\n\n1. Use design tokens for consistent theming.\n2. Avoid direct use of hex colors; use design tokens instead.\n3. Use `useCallback` and `useMemo` for performance optimization.\n4. Keep components small and focused on a single responsibility.\n5. Use TypeScript interfaces and types for defining data structures.\n6. Use `async/await` for handling asynchronous operations.\n7. Use `try/catch` blocks for error handling in asynchronous functions.\n8. Use `useEffect` for side effects in functional components.\n9. Use `useState` for managing local component state.\n10. Use `useReducer` for complex state management scenarios.\n\nRemember: The RedX Admin Hub is designed to streamline administrative tasks and enhance operational efficiency within the RedX platform."
    },
    "api_integration": {
      "purpose": "API Integration",
      "systemPrompt": "# GitHub Copilot Instructions for RedX Admin Hub\n\n---\n\n## applyTo: '**'\n\nThis file serves as the authoritative guide for AI coding assistants working on the RedX Admin Hub project. It provides comprehensive instructions on the project's architecture, code style, state management, component patterns, API integration, and more. AI coding assistants should use this document to ensure that any code generated is consistent with the project's established conventions and patterns.\n\n## Project Overview\n\nThe RedX Admin Hub is a web application designed for administrative users of the RedX platform. Its primary purpose is to manage and oversee various operational aspects of the RedX service, including parcel tracking and user authentication. The application is built using React and TypeScript, with a focus on providing a responsive and user-friendly interface. The primary users are administrative staff who require access to detailed operational data and management tools. The project operates within the logistics and delivery business domain, supporting functionalities such as parcel management and user authentication.\n\n## Architecture & Technology Stack\n\n### Core Technologies\n\n- **React**: A JavaScript library for building user interfaces.\n- **TypeScript**: A typed superset of JavaScript that compiles to plain JavaScript.\n- **Ant Design**: A UI library for building rich user interfaces.\n- **Emotion**: A library for writing CSS styles with JavaScript.\n- **Redux Toolkit**: A library for managing application state.\n- **Axios**: A promise-based HTTP client for the browser and Node.js.\n\n### Project Structure\n\n```plaintext\n.\n├── .gitignore\n├── bun.lockb\n├── components.json\n├── eslint.config.js\n├── index.html\n├── package-lock.json\n├── package.json\n├── postcss.config.js\n├── README.md\n├── tailwind.config.ts\n├── tsconfig.app.json\n├── tsconfig.json\n├── tsconfig.node.json\n├── vite.config.ts\n├── vitest.config.ts\n├── public\n│   ├── favicon.ico\n│   ├── placeholder.svg\n│   └── robots.txt\n└── src\n    ├── assets\n    │   └── globalStyles.ts\n    ├── components\n    │   ├── authorize\n    │   │   └── Authorize.tsx\n    │   ├── layout\n    │   │   └── AppLayout.tsx\n    │   ├── table\n    │   │   └── TableRenderer.tsx\n    │   └── ui\n    │       ├── accordion.tsx\n    │       ├── alert-dialog.tsx\n    │       ├── alert.tsx\n    │       ├── aspect-ratio.tsx\n    │       ├── avatar.tsx\n    │       ├── badge.tsx\n    │       ├── breadcrumb.tsx\n    │       ├── button.tsx\n    │       ├── calendar.tsx\n    │       ├── card.tsx\n    │       ├── carousel.tsx\n    │       ├── chart.tsx\n    │       ├── checkbox.tsx\n    │       ├── collapsible.tsx\n    │       ├── command.tsx\n    │       ├── context-menu.tsx\n    │       ├── dialog.tsx\n    │       ├── drawer.tsx\n    │       ├── dropdown-menu.tsx\n    │       ├── form.tsx\n    │       ├── hover-card.tsx\n    │       ├── input-otp.tsx\n    │       ├── input.tsx\n    │       ├── label.tsx\n    │       ├── menubar.tsx\n    │       ├── navigation-menu.tsx\n    │       ├── pagination.tsx\n    │       ├── popover.tsx\n    │       ├── progress.tsx\n    │       ├── radio-group.tsx\n    │       ├── resizable.tsx\n    │       ├── scroll-area.tsx\n    │       ├── select.tsx\n    │       ├── separator.tsx\n    │       ├── sheet.tsx\n    │       ├── sidebar.tsx\n    │       ├── skeleton.tsx\n    │       ├── slider.tsx\n    │       ├── sonner.tsx\n    │       ├── switch.tsx\n    │       ├── table.tsx\n    │       ├── tabs.tsx\n    │       ├── textarea.tsx\n    │       ├── toast.tsx\n    │       ├── toaster.tsx\n    │       ├── toggle-group.tsx\n    │       ├── toggle.tsx\n    │       └── tooltip.tsx\n    ├── config\n    │   ├── getPagePermissions.ts\n    │   ├── local.ts\n    │   └── navigation.ts\n    ├── hooks\n    │   ├── use-mobile.tsx\n    │   ├── use-toast.ts\n    │   ├── useAuthorization.ts\n    │   └── useTable.ts\n    ├── lib\n    │   ├── formHelpers.ts\n    │   └── utils.ts\n    ├── pages\n    │   ├── Index.tsx\n    │   ├── Login.tsx\n    │   ├── NotFound.tsx\n    │   └── Parcels.tsx\n    ├── redux\n    │   ├── slices\n    │   │   └── AuthSlice.ts\n    │   └── store.ts\n    ├── services\n    │   ├── authAPI.ts\n    │   ├── axios.config.ts\n    │   └── parcelAPI.ts\n    ├── test\n    │   ├── example.test.ts\n    │   └── setup.ts\n    ├── types\n    │   ├── auth.ts\n    │   └── parcel.ts\n    ├── App.css\n    ├── App.tsx\n    ├── index.css\n    ├── main.tsx\n    └── vite-env.d.ts\n```\n\n## Code Style & Standards\n\n### Formatting & Linting\n\nThe project does not have Prettier or ESLint configurations present, and there is no commitlint configuration. However, the TypeScript configuration is set up with the following options:\n\n```json\n{\n  \"strict\": false,\n  \"jsx\": null,\n  \"baseUrl\": \".\",\n  \"pathAliases\": {\n    \"@/*\": [\n      \"./src/*\"\n    ]\n  }\n}\n```\n\n### Import Organization\n\nThe preferred import order is as follows: framework → UI library → third-party → local hooks → redux/state → services → constants → types. Here is an annotated example:\n\n```typescript\n// Framework imports\nimport React, { useState, useCallback } from 'react';\n\n// UI library imports\nimport { Input, Select, Button } from 'antd';\nimport { SearchOutlined } from '@ant-design/icons';\n\n// Third-party imports\nimport { css } from '@emotion/react';\n\n// Local hooks\nimport { useTable } from '@/hooks/useTable';\n\n// Redux/state imports\nimport { setUser } from '@/redux/slices/AuthSlice';\n\n// Services\nimport { fetchParcels } from '@/services/parcelAPI';\n\n// Constants\nimport { ParcelStatus } from '@/types/parcel';\n\n// Types\nimport type { ColumnsType } from 'antd/es/table';\n```\n\n## State Management\n\n### Redux Toolkit\n\nThe project uses Redux Toolkit for state management. The configuration and setup are as follows:\n\n#### Store Configuration\n\n```typescript\nimport { configureStore } from '@reduxjs/toolkit';\nimport { persistStore } from 'redux-persist';\nimport persistedReducer from './reducers';\n\nexport const store = configureStore({\n  reducer: persistedReducer,\n  middleware: (getDefaultMiddleware) =>\n    getDefaultMiddleware({\n      serializableCheck: {\n        ignoredActions: [\n          'persist/PERSIST',\n          'persist/REHYDRATE',\n          'persist/PAUSE',\n          'persist/PURGE',\n          'persist/REGISTER',\n        ],\n      },\n    }),\n});\n\nexport const persistor = persistStore(store);\nexport type RootState = ReturnType<typeof store.getState>;\nexport type AppDispatch = typeof store.dispatch;\n```\n\n#### Auth Slice Example\n\n```typescript\nimport { createSlice, PayloadAction } from '@reduxjs/toolkit';\nimport { AuthState, User } from '@/types/auth';\n\nconst initialState: AuthState = {\n  user: null,\n  isAuthenticated: false,\n};\n\nconst authSlice = createSlice({\n  name: 'auth',\n  initialState,\n  reducers: {\n    setUser(state, action: PayloadAction<User>) {\n      state.user = action.payload;\n      state.isAuthenticated = true;\n    },\n    clearAuth(state) {\n      state.user = null;\n      state.isAuthenticated = false;\n    },\n  },\n});\n\nexport const { setUser, clearAuth } = authSlice.actions;\nexport default authSlice.reducer;\n```\n\n### Typed Hooks\n\nTyped hooks such as `useAppDispatch` and `useAppSelector` are not used in this project. Instead, direct usage of `useDispatch` and `useSelector` is observed.\n\n## Component Patterns\n\n### Page Structure with Authorization\n\nThe `Parcels` page demonstrates the use of authorization components:\n\n```typescript\n/** @jsxImportSource @emotion/react */\nimport { css } from '@emotion/react';\nimport { useState, useCallback } from 'react';\nimport {\n  Input,\n  Select,\n  Button,\n  Tag,\n  Space,\n  Modal,\n  Typography,\n  message,\n} from 'antd';\nimport { SearchOutlined, ReloadOutlined } from '@ant-design/icons';\nimport type { ColumnsType } from 'antd/es/table';\nimport Authorize from '@/components/authorize/Authorize';\nimport AppLayout from '@/components/layout/AppLayout';\nimport TableRenderer from '@/components/table/TableRenderer';\nimport { useTable } from '@/hooks/useTable';\nimport { fetchParcels } from '@/services/parcelAPI';\nimport { Parcel, FetchParcelsParams } from '@/types/parcel';\n\nconst { Title, Text } = Typography;\n\nconst searchBarStyle = css`\n  display: flex;\n  gap: 12px;\n  margin-bottom: 20px;\n  flex-wrap: wrap;\n  align-items: flex-end;\n```\n\n### Permission-Based Conditional Rendering\n\nThe `useAuthorization` hook is used for permission-based rendering:\n\n```typescript\nexport const useAuthorization = ({\n  roles,\n}: UseAuthorizationProps): {\n  isAuthorized: boolean;\n  isAuthenticated: boolean;\n} => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) =>\n    userRoleNames.includes(role),\n  );\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n### Primary Form Handling Pattern\n\nThe project uses Ant Design's `Form` component for form handling:\n\n```typescript\nimport { Form, Input, Button, message } from 'antd';\nimport { useDispatch } from 'react-redux';\nimport { setUser } from '@/redux/slices/AuthSlice';\nimport { requestLoginOtp, verifyOtp } from '@/services/authAPI';\n\nconst Login = () => {\n  const [loading, setLoading] = useState(false);\n  const [otpSent, setOtpSent] = useState(false);\n  const [form] = Form.useForm();\n  const dispatch = useDispatch();\n\n  const handleSendOtp = async () => {\n    try {\n      const phone = form.getFieldValue('phone');\n      if (!phone) {\n        message.error('Please enter phone number');\n        return;\n      }\n      setLoading(true);\n      await requestLoginOtp({ phone });\n      message.success('OTP sent successfully!');\n      setOtpSent(true);\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  const handleLogin = async () => {\n    try {\n      const values = await form.validateFields();\n      setLoading(true);\n      const res = await verifyOtp({\n        phone: values.phone,\n        otp: values.otp,\n      });\n      if (res.success && res.user) {\n        dispatch(setUser(res.user));\n        message.success('Login successful!');\n      } else {\n        message.error(res.error || 'Login failed');\n      }\n    } catch {\n      // validation error\n    } finally {\n      setLoading(false);\n    }\n  };\n\n  return (\n    <Form form={form} layout=\"vertical\" size=\"large\">\n      <Form.Item\n        name=\"phone\"\n        label=\"Phone Number\"\n        rules={[{ required: true, message: 'Phone is required' }]}\n      >\n        <Input placeholder=\"01XXXXXXXXX\" />\n      </Form.Item>\n      <Form.Item\n        name=\"otp\"\n        label=\"OTP\"\n        rules={[{ required: true, message: 'OTP is required' }]}\n      >\n        <Input />\n      </Form.Item>\n      <Button type=\"primary\" onClick={handleSendOtp} loading={loading}>\n        Send OTP\n      </Button>\n      <Button type=\"primary\" onClick={handleLogin} loading={loading}>\n        Login\n      </Button>\n    </Form>\n  );\n};\n```\n\n### Table/Data-Grid Pattern\n\nThe `useTable` hook is used for managing table data:\n\n```typescript\nimport { useState, useEffect, useCallback } from 'react';\n\ninterface UseTableParams {\n  limit: number;\n  offset: number;\n}\n\ninterface UseTableOptions<T, P extends UseTableParams> {\n  initialParams: P;\n  fetchFn: (params: P) => Promise<{ results: T[]; count: number }>;\n}\n\nexport const useTable = <T, P extends UseTableParams>({\n  initialParams,\n  fetchFn,\n}: UseTableOptions<T, P>) => {\n  const [params, setParams] = useState<P>(initialParams);\n  const [data, setData] = useState<T[]>([]);\n  const [total, setTotal] = useState(0);\n  const [loading, setLoading] = useState(false);\n\n  const fetchData = useCallback(async () => {\n    setLoading(true);\n    try {\n      const res = await fetchFn(params);\n      setData(res.results);\n      setTotal(res.count);\n    } finally {\n      setLoading(false);\n    }\n  }, [params, fetchFn]);\n\n  useEffect(() => {\n    fetchData();\n  }, [fetchData]);\n\n  const onPaginationChange = (page: number, pageSize: number) => {\n    setParams((prev) => ({\n      ...prev,\n      offset: (page - 1) * pageSize,\n      limit: pageSize,\n    }));\n  };\n\n  const onSearch = (searchParams: Partial<P>) => {\n    setParams((prev) => ({\n      ...prev,\n      ...searchParams,\n      offset: 0,\n    }));\n  };\n\n  const onReset = () => {\n    setParams(initialParams);\n  };\n\n  const updateRow = (\n    predicate: (item: T) => boolean,\n    updater: (item: T) => T,\n  ) => {\n    setData((prev) =>\n      prev.map((item) => (predicate(item) ? updater(item) : item)),\n    );\n  };\n\n  return {\n    data,\n    total,\n    loading,\n    params,\n    onPaginationChange,\n    onSearch,\n    onReset,\n    updateRow,\n  };\n};\n```\n\n### Styling Approach\n\nThe project uses Emotion for styling, as demonstrated in the `globalStyles.ts` file:\n\n```typescript\nimport { css } from '@emotion/react';\n\nexport const globalStyles = css`\n  body {\n    margin: 0;\n    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI',\n      Roboto, 'Helvetica Neue', Arial, sans-serif;\n    background: #f5f5f5;\n  }\n\n  #root {\n    min-height: 100vh;\n  }\n`;\n```\n\n## API Integration\n\n### HTTP Client Configuration\n\nThe project uses Axios for HTTP requests. The configuration is as follows:\n\n```typescript\nimport axios from 'axios';\n\nconst apiClient = axios.create({\n  baseURL: 'https://dummy-api.redx.local',\n  timeout: 5000,\n  headers: {\n    'Content-Type': 'application/json',\n  },\n});\n\nexport default apiClient;\n```\n\n### Service Layer Pattern\n\nThe canonical service module shape is demonstrated in the `authAPI.ts` file:\n\n```typescript\nexport const requestLoginOtp = async (\n  _data: OtpRequest,\n): Promise<{ success: boolean }> => {\n  await new Promise((r) => setTimeout(r, 500));\n  return { success: true };\n};\n\nexport const verifyOtp = async (\n  data: LoginPayload,\n): Promise<{ success: boolean; user?: User; error?: string }> => {\n  await new Promise((r) => setTimeout(r, 500));\n  if (data.otp === '123456') {\n    return {\n      success: true,\n      user: {\n        phone: data.phone,\n        roles: [{ name: 'RedX Super Admin' }],\n      },\n    };\n  }\n  return { success: false, error: 'Invalid OTP' };\n};\n```\n\n### Error Handling\n\nThe project uses Ant Design's `message` component for user feedback in error handling:\n\n```typescript\ntry {\n  const values = await form.validateFields();\n  setLoading(true);\n  const res = await verifyOtp({\n    phone: values.phone,\n    otp: values.otp,\n  });\n  if (res.success && res.user) {\n    dispatch(setUser(res.user));\n    message.success('Login successful!');\n  } else {\n    message.error(res.error || 'Login failed');\n  }\n} catch {\n  message.error('Validation error');\n} finally {\n  setLoading(false);\n}\n```\n\n## Navigation & Routing\n\nThe project uses React Router for navigation and routing. The configuration is as follows:\n\n```typescript\nimport { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';\nimport Login from './pages/Login';\nimport Parcels from './pages/Parcels';\nimport NotFound from './pages/NotFound';\n\nconst App = () => (\n  <BrowserRouter>\n    <Routes>\n      <Route path=\"/\" element={<Navigate to=\"/parcels\" replace />} />\n      <Route path=\"/login\" element={<Login />} />\n      <Route path=\"/parcels\" element={<Parcels />} />\n      <Route path=\"*\" element={<NotFound />} />\n    </Routes>\n  </BrowserRouter>\n);\n```\n\n### Menu/Navigation Configuration\n\nThe navigation configuration is defined in `navigation.ts`:\n\n```typescript\nexport interface NavItem {\n  key: string;\n  label: string;\n  path: string;\n  roles: string[];\n}\n\nexport const navigationItems: NavItem[] = [\n  {\n    key: 'parcels',\n    label: 'Parcels',\n    path: '/parcels',\n    roles: ['RedX Super Admin', 'RedX Finance Team'],\n  },\n];\n```\n\n## Authentication & Authorization\n\n### Authentication Flow\n\nThe authentication flow involves sending an OTP to the user's phone and verifying it:\n\n1. User enters their phone number.\n2. An OTP is sent to the phone number.\n3. User enters the OTP.\n4. The OTP is verified, and the user is authenticated.\n\n### Hook-Based Authorization\n\nThe `useAuthorization` hook is used to check user roles and permissions:\n\n```typescript\nexport const useAuthorization = ({\n  roles,\n}: UseAuthorizationProps): {\n  isAuthorized: boolean;\n  isAuthenticated: boolean;\n} => {\n  const auth = useSelector((state: RootState) => state.auth);\n\n  if (!auth.isAuthenticated || !auth.user) {\n    return { isAuthorized: false, isAuthenticated: false };\n  }\n\n  const userRoleNames = auth.user.roles.map((r) => r.name);\n  const isAuthorized = roles.some((role) =>\n    userRoleNames.includes(role),\n  );\n\n  return { isAuthorized, isAuthenticated: true };\n};\n```\n\n## Common Utilities\n\n### Form Helpers\n\nThe `formHelpers.ts` file contains utility functions for form handling:\n\n```typescript\nexport const handleNumericValueChange = (\n  value: string,\n): string => {\n  return value.replace(/[^0-9]/g, '');\n};\n\nexport const disableFutureDates = (current: Dayjs): boolean => {\n  return current && current.valueOf() > Date.now();\n};\n```\n\n### Utility Functions\n\nThe `utils.ts` file contains utility functions for class name merging:\n\n```typescript\nimport { twMerge } from 'tailwind-merge';\nimport clsx from 'clsx';\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n```\n\n## Testing & Quality\n\n### Testing Framework\n\nThe project uses Vitest for testing, with the configuration defined in `vitest.config.ts`:\n\n```typescript\nexport default defineConfig({\n  plugins: [react()],\n  test: {\n    environment: 'jsdom',\n    globals: true,\n    setupFiles: ['./src/test/setup.ts'],\n    include: ['src/**/*.{test,spec}.{ts,tsx}'],\n  },\n  resolve: {\n    alias: { '@': path.resolve(__dirname, './src') },\n  },\n});\n```\n\n### Test-ID Conventions\n\nThe project uses `data-testid` attributes for testing, as seen in the `Login.tsx` file:\n\n```typescript\n<Form.Item\n  name=\"phone\"\n  label=\"Phone Number\"\n  rules={[{ required: true, message: 'Phone is required' }]}\n>\n  <Input data-testid=\"phone-input\" placeholder=\"01XXXXXXXXX\" />\n</Form.Item>\n```\n\n## Environment Variables\n\nThe project does not specify any required environment variables in the provided data.\n\n## Development Workflow\n\n### Local Development\n\nTo set up the project locally, use the following commands:\n\n```bash\n# Install dependencies\nnpm install\n\n# Start the development server\nnpm run dev\n\n# Build the project\nnpm run build\n\n# Start the production server\nnpm start\n```\n\n### Local Setup Requirements\n\n- Node.js version: 14.x or higher\n- Package manager: npm\n- External services: None specified\n\n### Git Workflow\n\nThe project does not specify a conventional commits format, branch naming convention, or CI/CD pipeline details.\n\n## Performance Considerations\n\nThe project does not specify any code splitting strategy, lazy loading, tree-shaking setup, or bundle analysis tools.\n\n## Common Patterns to Follow\n\n1. Use Emotion for styling components.\n2. Use Ant Design components for consistent UI patterns.\n3. Wrap route content with `Authorize` where access control is required.\n4. Use `useTable` hook for managing table data.\n5. Use `useAuthorization` hook for permission-based rendering.\n6. Use `axios` for HTTP requests with a centralized configuration.\n7. Use Redux Toolkit for state management.\n8. Use `data-testid` attributes for testing.\n9. Use `Form` component from Ant Design for form handling.\n10. Use `message` component from Ant Design for user feedback.\n11. Use `useDispatch` and `useSelector` for accessing Redux state.\n12. Use TypeScript for type safety and improved developer experience.\n\n## Domain-Specific Features\n\n### Parcel Management\n\n- **Purpose**: Manage and track parcels within the RedX platform.\n- **Key Components**: `Parcels.tsx`, `TableRenderer.tsx`\n- **Special Patterns**: Use of `useTable` hook for data management and `Authorize` component for access control.\n\n### User Authentication\n\n- **Purpose**: Authenticate users via OTP.\n- **Key Components**: `Login.tsx`, `authAPI.ts`\n- **Special Patterns**: OTP-based authentication flow with Redux state management.\n\n## Debugging & Development Tools\n\nThe project does not specify any DevTools integration or logging patterns.\n\n## Migration Notes\n\nNo ongoing migrations are detected in the project.\n\n## Best Practices\n\n1. Use design tokens for consistent theming.\n2. Avoid direct use of hex colors; use design tokens instead.\n3. Use `useCallback` and `useMemo` for performance optimization.\n4. Keep components small and focused on a single responsibility.\n5. Use TypeScript interfaces and types for defining data structures.\n6. Use `async/await` for handling asynchronous operations.\n7. Use `try/catch` blocks for error handling in asynchronous functions.\n8. Use `useEffect` for side effects in functional components.\n9. Use `useState` for managing local component state.\n10. Use `useReducer` for complex state management scenarios.\n\nRemember: The RedX Admin Hub is designed to streamline administrative tasks and enhance operational efficiency within the RedX platform."
    }
  }
}